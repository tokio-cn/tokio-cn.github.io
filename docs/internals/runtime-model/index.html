<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <link rel="apple-touch-icon" sizes="120x120" href="https://tokio-cn.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://tokio-cn.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://tokio-cn.github.io/favicon-16x16.png">
    <link rel="manifest" href="https://tokio-cn.github.io/manifest.json">
    <link rel="mask-icon" href="https://tokio-cn.github.io/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="theme-color" content="#ffffff">

    
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap-reboot.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/tokio.css">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/>

    
    <link rel="alternate" type="application/rss+xml" href="https://tokio-cn.github.io/blog/index.xml" />

    <title>
      
        Runtime model · Tokio 中文站
      
    </title>
  </head>
  <body>
    <header class="navbar navbar-expand navbar-dark flex-column flex-md-row tk-navbar">
      <a class="navbar-brand" href="https://tokio-cn.github.io/">
        <img src="https://tokio-cn.github.io/img/Tokio_Mark_White.png" class="align-middle" alt="">
      </a>
      <div class="collapse navbar-collapse">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link " href="https://tokio-cn.github.io/">首页</a>
          </li>
          <li class="nav-item">
            
            
            
            <a class="nav-link  active " href="https://tokio-cn.github.io/docs/getting-started/hello-world/">文档</a>
          </li>
          <li class="nav-item">
            
            <a class="nav-link " href="https://tokio-cn.github.io/community/">社区</a>
          </li>
          <li class="nav-item">
            
            
            <a class="nav-link " href="https://tokio-cn.github.io/blog/2018-12-recap-2018/">博客</a>
          </li>
        </ul>
      </div>

      <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
        <li class="nav-item dropdown">
          <a class="nav-item nav-link dropdown-toggle mr-md-2" href="#" id="tk-langs" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            中文
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="tk-langs">
            <a class="dropdown-item active" href="#">中文</a>
            <a class="dropdown-item" href="https://tokio-zh.github.io/" rel="nofollow">官方中文</a>
            <a class="dropdown-item" href="https://tokio.rs" rel="nofollow">English</a>
          </div>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://github.com/tokio-rs/tokio" target="_blank" rel="noopener" aria-label="GitHub">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 499.36" focusable="false"><title>GitHub</title><path d="M256 0C114.64 0 0 114.61 0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34 0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49 0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75 0 0 21.49-6.88 70.4 26.24a242.65 242.65 0 0 1 128.18 0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69 0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41 0 34.22-.31 61.83-.31 70.23 0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37 0 256 0z" fill="currentColor" fill-rule="evenodd"/></svg>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://twitter.com/tokio_rs" target="_blank" rel="noopener" aria-label="Twitter">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 416.32" focusable="false"><title>Twitter</title><path d="M160.83 416.32c193.2 0 298.92-160.22 298.92-298.92 0-4.51 0-9-.2-13.52A214 214 0 0 0 512 49.38a212.93 212.93 0 0 1-60.44 16.6 105.7 105.7 0 0 0 46.3-58.19 209 209 0 0 1-66.79 25.37 105.09 105.09 0 0 0-181.73 71.91 116.12 116.12 0 0 0 2.66 24c-87.28-4.3-164.73-46.3-216.56-109.82A105.48 105.48 0 0 0 68 159.6a106.27 106.27 0 0 1-47.53-13.11v1.43a105.28 105.28 0 0 0 84.21 103.06 105.67 105.67 0 0 1-47.33 1.84 105.06 105.06 0 0 0 98.14 72.94A210.72 210.72 0 0 1 25 370.84a202.17 202.17 0 0 1-25-1.43 298.85 298.85 0 0 0 160.83 46.92" fill="currentColor"/></svg>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://gitter.im/tokio-rs/tokio" target="_blank" rel="noopener" aria-label="Gitter">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" focusable="false"><title>Gitter</title><path fill="currentColor" d="M8.501 4.001H10.5V24H8.501V4.001zm6.999 0V24h-2V4.001h2zM3.5 0h2.001v15H3.5V0zm15 4.001h2V15h-2V4.001z"/></svg>
          </a>
        </li>
      </ul>
    </header>



<div class="container-fluid tk-docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 tk-sidebar">
      <form class="tk-search d-flex align-items-center">
        <span class="algolia-autocomplete algolia-autocomplete-left" style="position: relative; display: inline-block; direction: ltr;">
          <input class="form-control ds-input" id="search-input" placeholder="搜索……" autocomplete="off" spellcheck="false" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-owns="algolia-autocomplete-listbox-0" style="position: relative; vertical-align: top;" dir="auto" type="search">
          <pre aria-hidden="true" style="position: absolute; visibility: hidden; white-space: pre; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-style: normal; font-variant: normal; font-weight: 400; word-spacing: 0px; letter-spacing: normal; text-indent: 0px; text-rendering: optimizelegibility; text-transform: none;">w</pre>
          <span class="ds-dropdown-menu ds-with-1" style="position: absolute; top: 100%; left: 0px; z-index: 100; right: auto; display: none;" role="listbox" id="algolia-autocomplete-listbox-0">
            <div class="ds-dataset-1"></div>
          </span>
        </span>
        <button class="btn btn-link tk-search-docs-toggle d-md-none p-0 ml-3" type="button" data-toggle="collapse" data-target="#tk-docs-nav" aria-controls="tk-docs-nav" aria-expanded="false" aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false">
            <title>Menu</title><path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"></path></svg>
        </button>
      </form>

      <nav class="tk-links collapse" id="tk-docs-nav">
          
          
            
              <div class="tk-toc-item">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/overview/">
                  Tokio 是什么？
                </a>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/getting-started/hello-world/">
                  入门
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/hello-world/" class="">Hello World!</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/futures/" class="">Futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/runtime/" class="">Runtime</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/echo/" class="">Example: An Echo Server</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/futures/overview/">
                  使用 future
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/overview/" class="">Overview</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/basic/" class="">Implementing futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/getting_asynchronous/" class="">Getting asynchronous</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/combinators/" class="">Combinators</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/streams/" class="">Streams</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/spawning/" class="">Spawning</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/leaf-futures/" class="">Leaf futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/runtime-model/" class="">Runtime model</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/io/overview/">
                  使用 Tokio 的 I/O
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/io/overview/" class="">I/O Overview</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/reading_writing_data/" class="">Reading and Writing Data</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/async_read_write/" class="">Using AsyncRead and AsyncWrite directly</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/impl_async_read_write/" class="">Implementing Async Read/Write</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/filesystem/" class="">Filesystem APIs</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/datagrams/" class="">Datagram APIs</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/going-deeper/futures/">
                  深入
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/futures/" class="">Futures: In Depth</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/tasks/" class="">Tasks</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/runtime-model/" class="">运行时模型</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/io/" class="">I/O with Tokio</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/chat/" class="">Example: A Chat Server</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/timers/" class="">Timers</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/futures-mechanics/" class="">Essential combinators</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/returning/" class="">Returning futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/frames/" class="">Working with framed streams</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/building-runtime/" class="">Building a runtime</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item active">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/internals/intro/">
                  Tokio 内部原理
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/intro/" class="">Introduction</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/runtime-model/" class="active">Runtime model</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/net/" class="">Non-blocking I/O</a></li>
                
                </ul>
              </div>
            
          
            
              <div class="tk-toc-item">
                <a class="tk-toc-link" href="https://docs.rs/tokio">
                  API 文档
                </a>
              </div>
            
          
      </nav>
    </div>
    <div class="d-none d-xl-block col-xl-2 tk-toc">
      <div class="section-nav">
        <nav id="TableOfContents">
<ul>
<li><a href="#non-blocking-execution">Non-blocking execution</a>
<ul>
<li><a href="#cooperative-scheduling">Cooperative scheduling</a></li>
</ul></li>
<li><a href="#task-system">Task system</a>
<ul>
<li><a href="#task-current-and-task-notify"><code>task::current</code> and <code>Task::notify</code></a></li>
<li><a href="#async-notready"><code>Async::NotReady</code></a>
<ul>
<li><a href="#yielding">Yielding</a></li>
</ul></li>
</ul></li>
<li><a href="#executors">Executors</a></li>
<li><a href="#resources-drivers-and-runtimes">Resources, drivers, and runtimes</a></li>
<li><a href="#future">Future</a></li>
</ul>
</nav>
      </div>
    </div>
    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 tk-content tk-docs">
      <h1 class="tk-title">Runtime model</h1>
      <div class="github-edit">
        <a class="fa fa-github" href="https://github.com/hltj/tokio-website-cn/tree/master/content/docs/internals/runtime-model.md"> 在 GitHub 上编辑</a>
      </div>
      

<p>Applications written using Tokio are organized across a large number of small,
non-blocking tasks. A Tokio task is similar to a <a href="https://www.golang-book.com/books/intro/10#section1">goroutine</a> or an
<a href="http://erlang.org/doc/reference_manual/processes.html">Erlang process</a>, but is non-blocking. They are designed to be
lightweight, can be spawned fast, and maintain low scheduling overhead. They are
also non-blocking, as such operations that are not able to finish immediately
must still return immediately. Instead of returning the result of the operation,
they return a value indicating that the operation is in progress.</p>

<h1 id="non-blocking-execution">Non-blocking execution</h1>

<p>A Tokio task is implemented using the <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>Future</code></a> trait:</p>

<pre><code class="language-rust"># extern crate futures;
# use futures::*;
# type MyResource = future::FutureResult&lt;(), ()&gt;;
struct MyTask {
    my_resource: MyResource,
}
# impl MyTask {
#     fn process(&amp;self, _: ()) {}
#     fn process_err(&amp;self, _: ()) {}
# }

impl Future for MyTask {
    type Item = ();
    type Error = ();

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        match self.my_resource.poll() {
            Ok(Async::Ready(value)) =&gt; {
                self.process(value);
                Ok(Async::Ready(()))
            }
            Ok(Async::NotReady) =&gt; Ok(Async::NotReady),
            Err(err) =&gt; {
                self.process_err(err);
                Ok(Async::Ready(()))
            }
        }
    }
}
</code></pre>

<p>Tasks are submitted to an executor using <code>tokio::spawn</code> or by calling a <code>spawn</code>
method on an executor object. The <code>poll</code> function drives the task. No work is
done without calling <code>poll</code>. It is the executor&rsquo;s job to call <code>poll</code> on the task
until <code>Ready(())</code> is returned.</p>

<p><code>MyTask</code> will receive a value from <code>my_resource</code> and process it. Once the value
has been processed, the task has completed its logic and is done. This is
represented by returning <code>Ok(Async::Ready(()))</code>.</p>

<p>However, in order to complete processing, the task depends on <code>my_resource</code>
providing a value. Given that <code>my_resource</code> is a non-blocking task, it may or
may not be ready to provide the value when <code>my_resource.poll()</code> is called. If it
is ready, it returns <code>Ok(Async::Ready(value))</code>. If it is not ready, it returns
<code>Ok(Async::NotReady)</code>.</p>

<p>When the resource is not ready to provide a value, this implies that the task
itself is not ready to complete and the task&rsquo;s <code>poll</code> function returns
<code>NotReady</code> as well.</p>

<p>At some point in the future, the resource will become ready to provide the
value. The resource uses the task system to signal to the executor that it is
ready. The executor schedules the task, which leads to <code>MyTask::poll</code> being
called again. This time, given that <code>my_resource</code> is ready, the value will be
returned from <code>my_resource.poll()</code> and the task is able to complete.</p>

<h2 id="cooperative-scheduling">Cooperative scheduling</h2>

<p>Cooperative scheduling is used to schedule tasks on executors. A single executor
is expected to manage many tasks across a small set of threads. There will be
a far greater number of tasks than threads. There also is no pre-emption. This
means that when a task is scheduled to execute, it blocks the current thread
until the <code>poll</code> function returns.</p>

<p>Because of this, it is important for implementations of <code>poll</code> to only execute
for very short periods of time. For I/O bound applications, this usually happens
automatically. However, if a task must run a longer computation, it should defer
work to a <a href="https://docs.rs/tokio-threadpool/0.1/tokio_threadpool/fn.blocking.html">blocking pool</a> or break up the computation into smaller chunks and
<a href="#yielding">yield</a> back to the executor after each chunk.</p>

<h1 id="task-system">Task system</h1>

<p>The task system is the system by which resources notify executors of readiness
changes. A task is composed of non-blocking logic that consume resources. In the
example above, <code>MyTask</code> uses a single resource, <code>my_resource</code>, but there is no
limit to the number of resources that a task can consume.</p>

<p>When a task is executing and attempts to use a resource that is not ready, it
becomes <em>logically</em> blocked on that resource, i.e., the task is not able to make
further progress until that resource becomes ready. Tokio tracks which resources
a task is currently blocked on to make forward progress. When a dependent
resource becomes ready, the executor schedules the task. This is done by
tracking when a task <strong>expresses interest</strong> in a resource.</p>

<p>When <code>MyTask</code> executes, attempts to consume <code>my_resource</code>, and <code>my_resource</code>
returns <code>NotReady</code>, <code>MyTask</code> has implicitly expressed interest in the
<code>my_resource</code> resource. At this point the task and the resource are linked. When
the resource becomes ready, the task is scheduled again.</p>

<h2 id="task-current-and-task-notify"><code>task::current</code> and <code>Task::notify</code></h2>

<p>Tracking interest and notifying readiness changes is done with two APIs:</p>

<ul>
<li><a href="https://docs.rs/futures/0.1/futures/task/fn.current.html"><code>task::current</code></a></li>
<li><a href="https://docs.rs/futures/0.1/futures/task/struct.Task.html#method.notify"><code>Task::notify</code></a></li>
</ul>

<p>When <code>my_resource.poll()</code> is called, if the resource is ready, it immediately
returns the value without using the task system. If the resource is <strong>not</strong>
ready, it gets a handle to the current task by calling <a href="https://docs.rs/futures/0.1/futures/task/fn.current.html"><code>task::current() -&gt;
Task</code></a>. This handle is obtained by reading a thread-local variable set
by the executor.</p>

<p>Some external event (data received on the network, background thread completing
a computation, etc&hellip;) will result in <code>my_resource</code> becoming ready to produce
its value. At that point, the logic that readies <code>my_resource</code> will call
<a href="https://docs.rs/futures/0.1/futures/executor/trait.Notify.html"><code>notify</code></a> on the task handle obtained from <a href="https://docs.rs/futures/0.1/futures/task/fn.current.html"><code>task::current</code></a>. This
signals the readiness change to the executor, which then schedules the task for
execution.</p>

<p>If multiple tasks have expressed interest in a resource, only the <em>last</em> task to
have done so will be notified. Resources are intended to be used from a single
task only.</p>

<h2 id="async-notready"><code>Async::NotReady</code></h2>

<p>Any function that returns <code>Async</code> must adhere to the <a href="https://docs.rs/futures/0.1.23/futures/future/trait.Future.html#tymethod.poll">contract</a>. When
<code>NotReady</code> is returned, the current task <strong>must</strong> have been registered for
notification on readiness change. The implication for resources is discussed in
the above section. For task logic, this means that <code>NotReady</code> cannot be returned
unless a resource has returned <code>NotReady</code>. By doing this, the
<a href="https://docs.rs/futures/0.1.23/futures/future/trait.Future.html#tymethod.poll">contract</a> transitively upheld. The current task is registered for
notification because <code>NotReady</code> has been received from the resource.</p>

<p>Great care must be taken to avoiding returning <code>NotReady</code> without having
received <code>NotReady</code> from a resource. For example, the following task
implementation results in the task never completing.</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# #[macro_use]
# extern crate futures;
use futures::{Future, Poll, Async};

# type Resource1 = futures::future::FutureResult&lt;(), ()&gt;;
# struct Resource2;
# impl Resource2 {
#     fn new(_: ()) -&gt; Self { Resource2 }
# }
# impl Future for Resource2 {
#    type Item = ();
#    type Error = ();
#    fn poll(&amp;mut self) -&gt; Poll&lt;(), ()&gt; { unimplemented!(); }
# }
enum BadTask {
    First(Resource1),
    Second(Resource2),
}

impl Future for BadTask {
    type Item = ();
    type Error = ();

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        use self::BadTask::*;
        let value = match *self {
            First(ref mut resource) =&gt; {
                try_ready!(resource.poll())
            }
            Second(ref mut resource) =&gt; {
                try_ready!(resource.poll());
                return Ok(Async::Ready(()));
            }
        };

        *self = Second(Resource2::new(value));
        Ok(Async::NotReady)
    }
}
# fn main() {}
</code></pre>

<p>The problem with the above implementation is that <code>Ok(Async::NotReady)</code> is
returned right after transitioning the state to <code>Second</code>. During this
transition, no resource has returned <code>NotReady</code>. When the task itself returns
<code>NotReady</code>, it has violated the <a href="https://docs.rs/futures/0.1.23/futures/future/trait.Future.html#tymethod.poll">contract</a> as the task will <strong>not</strong> be
notified in the future.</p>

<p>This situation is generally resolved by adding a loop:</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# #[macro_use]
# extern crate futures;
use futures::{Future, Poll, Async};

# type Resource1 = futures::future::FutureResult&lt;(), ()&gt;;
# struct Resource2;
# impl Resource2 {
#     fn new(_: ()) -&gt; Self { Resource2 }
# }
# impl Future for Resource2 {
#    type Item = ();
#    type Error = ();
#    fn poll(&amp;mut self) -&gt; Poll&lt;(), ()&gt; { unimplemented!(); }
# }
# enum BadTask {
#     First(Resource1),
#     Second(Resource2),
# }
# impl Future for BadTask {
# type Item = ();
# type Error = ();
fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
    use self::BadTask::*;
    loop {
        let value = match *self {
            First(ref mut resource) =&gt; {
                try_ready!(resource.poll())
            }
            Second(ref mut resource) =&gt; {
                try_ready!(resource.poll());
                return Ok(Async::Ready(()));
            }
        };

        *self = Second(Resource2::new(value));
    }
}
# }
# fn main() {}
</code></pre>

<p>One way to think about it is that a task&rsquo;s <code>poll</code> function <strong>must not</strong>
return until it is unable to make any further progress due to its resources not
being ready or it explicitly yields (see below).</p>

<p>Also note that <strong>functions that return <code>Async</code> must only be called from a
task</strong>. In other words, these functions may only be called from code that has
been submitted to <code>tokio::spawn</code> or other task spawn function.</p>

<h3 id="yielding">Yielding</h3>

<p>Sometimes a task must return <code>NotReady</code> without being blocked on a resource.
This usually happens when computation to run is large and the task wants to
return control to the executor to allow it to execute other futures.</p>

<p>Yielding is done by notifying the current task and returning <code>NotReady</code>:</p>

<pre><code class="language-rust"># extern crate futures;
use futures::task;
use futures::Async;

# fn poll_dox() -&gt; Result&lt;Async&lt;()&gt;, ()&gt; {
// Yield the current task. The executor will poll this task next
// iteration through its run list.
task::current().notify();
return Ok(Async::NotReady);
# }
</code></pre>

<p>Yield can be used to break up a CPU expensive computation:</p>

<pre><code class="language-rust"># extern crate futures;
# use futures::*;
struct Count {
    remaining: usize,
}

impl Future for Count {
    type Item = ();
    type Error = ();

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        while self.remaining &gt; 0 {
            self.remaining -= 1;

            // Yield every 10 iterations
            if self.remaining % 10 == 0 {
                task::current().notify();
                return Ok(Async::NotReady);
            }
        }

        Ok(Async::Ready(()))
    }
}
</code></pre>

<h1 id="executors">Executors</h1>

<p>Executors are responsible for driving many tasks to completion. A task is
spawned onto an executor, at which point the executor calls its <code>poll</code> function
when needed. The executor hooks into the task system to receive resource
readiness notifications.</p>

<p>By decoupling the task system with the executor implementation, the specific
execution and scheduling logic can be left to the executor implementation. Tokio
provides two executor implementations, each with unique characteristics:
<a href="http://docs.rs/tokio-current-thread"><code>current_thread</code></a> and <a href="https://docs.rs/tokio-threadpool"><code>thread_pool</code></a>.</p>

<p>When a task is first spawned onto the executor, the executor wraps it with
<a href="https://docs.rs/futures/0.1/futures/executor/struct.Spawn.html"><code>Spawn</code></a>. This binds the task logic with the task state (this is mostly
required for legacy reasons). Executors will typically store the task on the
heap, usually by storing it in a <code>Box</code> or an <code>Arc</code>. When the executor picks a
task for execution, it calls <a href="https://docs.rs/futures/0.1/futures/executor/struct.Spawn.html#method.poll_future_notify"><code>Spawn::poll_future_notify</code></a>.
This function ensures that the task context is set to the thread-local variable
such that <a href="https://docs.rs/futures/0.1/futures/task/fn.current.html"><code>task::current</code></a> is able to read it.</p>

<p>When calling <a href="https://docs.rs/futures/0.1/futures/executor/struct.Spawn.html#method.poll_future_notify"><code>poll_future_notify</code></a>, the executor also
passes in a notify handle and an identifier. These arguments are included in the
task handle returned by <a href="https://docs.rs/futures/0.1/futures/task/fn.current.html"><code>task::current</code></a> and are how the task is
linked to the executor.</p>

<p>The notify handle is an implementation of <a href="https://docs.rs/futures/0.1/futures/executor/trait.Notify.html"><code>Notify</code></a> and the identifier
is a value that the executor uses to look up the current task. When
<a href="https://docs.rs/futures/0.1/futures/task/struct.Task.html#method.notify"><code>Task::notify</code></a> is called, the <a href="https://docs.rs/futures/0.1/futures/executor/trait.Notify.html#tymethod.notify"><code>notify</code></a> function on
the notify handle is called with the supplied identifier. The implementation of
this function is responsible for performing the scheduling logic.</p>

<p>One strategy for implementing an executor is to store each task in a <code>Box</code> and
to use a linked list to track tasks that are scheduled for execution. When
<a href="https://docs.rs/futures/0.1/futures/executor/trait.Notify.html#tymethod.notify"><code>Notify::notify</code></a> is called, then the task associated with the
identifier is pushed at the end of the <code>scheduled</code> linked list. When the
executor runs, it pops from the front of the linked list and executes the task
as described above.</p>

<p>Note that this section does not describe how the executor is run. The details of
this are left to the executor implementation. One option is for the executor to
spawn one or more threads and dedicate these threads to draining the <code>scheduled</code>
linked list. Another is to provide a <code>MyExecutor::run</code> function that blocks the
current thread and drains the <code>scheduled</code> linked list.</p>

<h1 id="resources-drivers-and-runtimes">Resources, drivers, and runtimes</h1>

<p>Resources are leaf futures, i.e. futures that are not implemented in terms of
other futures. They are the types that use the task system described above to
interact with the executor. Resource types include TCP and UDP sockets, timers,
channels, file handles, etc. Tokio applications rarely need to implement
resources. Instead, they use resources provided by Tokio or third party crates.</p>

<p>Oftentimes, a resource cannot function by itself and requires a driver. For
example, Tokio TCP sockets are backed by a <a href="https://docs.rs/tokio-reactor/0.1.5/tokio_reactor/"><code>Reactor</code></a>. The reactor is the
socket resource driver. A single driver may power large numbers of resource
instances. In order to use the resource, the driver must be running somewhere in
the process. Tokio provides drivers for network resources (<a href="https://docs.rs/tokio-reactor"><code>tokio-reactor</code></a>),
file resources (<a href="https://docs.rs/tokio-fs"><code>tokio-fs</code></a>), and timers (<a href="https://docs.rs/tokio-timer"><code>tokio-timer</code></a>). Providing decoupled
driver components allows users to pick and choose which components they wish to
use. Each driver can be used standalone or combined with other drivers.</p>

<p>Because of this, in order to use Tokio and successfully execute tasks, an
application must start an executor and the necessary drivers for the resources
that the application&rsquo;s tasks depend on. This requires significant boilerplate.
To manage the boilerplate, Tokio offers a couple of runtime options. A runtime
is an executor bundled with all necessary drivers to power Tokio&rsquo;s resources.
Instead of managing all the various Tokio components individually, a runtime is
created and started in a single call.</p>

<p>Tokio offers a <a href="https://docs.rs/tokio/0.1.8/tokio/runtime/index.html">concurrent runtime</a> and a
<a href="https://docs.rs/tokio/0.1.8/tokio/runtime/current_thread/index.html">single-threaded</a> runtimee. The concurrent runtime is backed by
a multi-threaded, work-stealing executor. The single-threaded runtime executes
all tasks and drivers on thee current thread. The user may pick the runtime with
characteristics best suited for the application.</p>

<h1 id="future">Future</h1>

<p>As mentioned above, tasks are implemented using the <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>Future</code></a> trait. This trait
is not limited to implementing tasks. A <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>Future</code></a> is a value that represents a
non-blocking computation that will complete sometime in the future. A task is a
computation with no output. Many resources in Tokio are represented with
<a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>Future</code></a> implementations. For example, a timeout is a <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>Future</code></a> that
completes once the deadline has been reached.</p>

<p>The trait includes a number of combinators that are useful for working with
future values.</p>

<p>Applications are built by either implementing <code>Future</code> for application specific
types or defining application logic using combinators. Often, a mix of both
strategies is most successful.</p>

<!-- TODO: Expand -->

      
      
        <div class="tk-next">
          <b>下一篇</b>：<a href ="/docs/internals/net/">Non-blocking I/O</a>
        </div>
      
    </main>
  </div>
</div>

    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js" integrity="sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8" crossorigin="anonymous"></script>
    <script src="https://tokio-cn.github.io/js/bootstrap.min.js"></script>
    <script src="https://tokio-cn.github.io/js/highlight.js"></script>
    <script>
      $(function () {
        $("pre code").each(function(i, block) {
          
          if (block.className.indexOf('language-rust') >= 0) {
            var new_content = '';
            var lines = block.textContent.split('\n');
            for (var i = 0; i < lines.length; i++) {
              if (lines[i].indexOf('# ') == 0 || lines[i] == '#') {
                continue
              }
              new_content += lines[i].trimRight() + '\n';
            }
            block.textContent = new_content.replace(/\n\n\n/g, "\n\n").trimRight();
          }
          hljs.highlightBlock(block);
        });
      });
    </script>
    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
    <script type="text/javascript"> docsearch({
    apiKey: 'd7b5b785798fe748621bcaa8301a2201',
    indexName: 'tokio',
    inputSelector: '#search-input',
    debug: false 
    });
    </script>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-122396021-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

