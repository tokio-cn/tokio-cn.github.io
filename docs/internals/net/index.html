<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <link rel="apple-touch-icon" sizes="120x120" href="https://tokio-cn.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://tokio-cn.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://tokio-cn.github.io/favicon-16x16.png">
    <link rel="manifest" href="https://tokio-cn.github.io/manifest.json">
    <link rel="mask-icon" href="https://tokio-cn.github.io/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="theme-color" content="#ffffff">

    
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap-reboot.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/tokio.css">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/>

    
    <link rel="alternate" type="application/rss+xml" href="https://tokio-cn.github.io/blog/index.xml" />

    <title>
      
        Non-blocking I/O · Tokio 中文站
      
    </title>
  </head>
  <body>
    <header class="navbar navbar-expand navbar-dark flex-column flex-md-row tk-navbar">
      <a class="navbar-brand" href="https://tokio-cn.github.io/">
        <img src="https://tokio-cn.github.io/img/Tokio_Mark_White.png" class="align-middle" alt="">
      </a>
      <div class="collapse navbar-collapse">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link " href="https://tokio-cn.github.io/">首页</a>
          </li>
          <li class="nav-item">
            
            
            
            <a class="nav-link  active " href="https://tokio-cn.github.io/docs/getting-started/hello-world/">文档</a>
          </li>
          <li class="nav-item">
            
            <a class="nav-link " href="https://tokio-cn.github.io/community/">社区</a>
          </li>
          <li class="nav-item">
            
            
            <a class="nav-link " href="https://tokio-cn.github.io/blog/2018-10-doc-blitz/">博客</a>
          </li>
        </ul>
      </div>

      <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
        <li class="nav-item dropdown">
          <a class="nav-item nav-link dropdown-toggle mr-md-2" href="#" id="tk-langs" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            中文
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="tk-langs">
            <a class="dropdown-item active" href="#">中文</a>
            <a class="dropdown-item" href="https://tokio-zh.github.io/" rel="nofollow">官方中文</a>
            <a class="dropdown-item" href="https://tokio.rs" rel="nofollow">English</a>
          </div>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://github.com/tokio-rs/tokio" target="_blank" rel="noopener" aria-label="GitHub">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 499.36" focusable="false"><title>GitHub</title><path d="M256 0C114.64 0 0 114.61 0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34 0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49 0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75 0 0 21.49-6.88 70.4 26.24a242.65 242.65 0 0 1 128.18 0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69 0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41 0 34.22-.31 61.83-.31 70.23 0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37 0 256 0z" fill="currentColor" fill-rule="evenodd"/></svg>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://twitter.com/tokio_rs" target="_blank" rel="noopener" aria-label="Twitter">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 416.32" focusable="false"><title>Twitter</title><path d="M160.83 416.32c193.2 0 298.92-160.22 298.92-298.92 0-4.51 0-9-.2-13.52A214 214 0 0 0 512 49.38a212.93 212.93 0 0 1-60.44 16.6 105.7 105.7 0 0 0 46.3-58.19 209 209 0 0 1-66.79 25.37 105.09 105.09 0 0 0-181.73 71.91 116.12 116.12 0 0 0 2.66 24c-87.28-4.3-164.73-46.3-216.56-109.82A105.48 105.48 0 0 0 68 159.6a106.27 106.27 0 0 1-47.53-13.11v1.43a105.28 105.28 0 0 0 84.21 103.06 105.67 105.67 0 0 1-47.33 1.84 105.06 105.06 0 0 0 98.14 72.94A210.72 210.72 0 0 1 25 370.84a202.17 202.17 0 0 1-25-1.43 298.85 298.85 0 0 0 160.83 46.92" fill="currentColor"/></svg>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://gitter.im/tokio-rs/tokio" target="_blank" rel="noopener" aria-label="Gitter">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" focusable="false"><title>Gitter</title><path fill="currentColor" d="M8.501 4.001H10.5V24H8.501V4.001zm6.999 0V24h-2V4.001h2zM3.5 0h2.001v15H3.5V0zm15 4.001h2V15h-2V4.001z"/></svg>
          </a>
        </li>
      </ul>
    </header>



<div class="container-fluid tk-docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 tk-sidebar">
      <form class="tk-search d-flex align-items-center">
        <span class="algolia-autocomplete algolia-autocomplete-left" style="position: relative; display: inline-block; direction: ltr;">
          <input class="form-control ds-input" id="search-input" placeholder="搜索……" autocomplete="off" spellcheck="false" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-owns="algolia-autocomplete-listbox-0" style="position: relative; vertical-align: top;" dir="auto" type="search">
          <pre aria-hidden="true" style="position: absolute; visibility: hidden; white-space: pre; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-style: normal; font-variant: normal; font-weight: 400; word-spacing: 0px; letter-spacing: normal; text-indent: 0px; text-rendering: optimizelegibility; text-transform: none;">w</pre>
          <span class="ds-dropdown-menu ds-with-1" style="position: absolute; top: 100%; left: 0px; z-index: 100; right: auto; display: none;" role="listbox" id="algolia-autocomplete-listbox-0">
            <div class="ds-dataset-1"></div>
          </span>
        </span>
        <button class="btn btn-link tk-search-docs-toggle d-md-none p-0 ml-3" type="button" data-toggle="collapse" data-target="#tk-docs-nav" aria-controls="tk-docs-nav" aria-expanded="false" aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false">
            <title>Menu</title><path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"></path></svg>
        </button>
      </form>

      <nav class="tk-links collapse" id="tk-docs-nav">
          
          
            
              <div class="tk-toc-item">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/overview/">
                  Tokio 是什么？
                </a>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/getting-started/hello-world/">
                  入门
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/hello-world/" class="">Hello World!</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/futures/" class="">Futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/runtime/" class="">Runtime</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/echo/" class="">Example: An Echo Server</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/futures/overview/">
                  Working with futures
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/overview/" class="">Overview</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/basic/" class="">Implementing futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/getting_asynchronous/" class="">Getting asynchronous</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/combinators/" class="">Combinators</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/streams/" class="">Streams</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/spawning/" class="">Spawning</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/leaf-futures/" class="">Leaf futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/runtime-model/" class="">Runtime model</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/io/overview/">
                  I/O with Tokio
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/io/overview/" class="">I/O Overview</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/reading_writing_data/" class="">Reading and Writing Data</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/async_read_write/" class="">Using AsyncRead and AsyncWrite directly</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/impl_async_read_write/" class="">Implementing Async Read/Write</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/filesystem/" class="">Filesystem APIs</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/datagrams/" class="">Datagram APIs</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/going-deeper/futures/">
                  深入
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/futures/" class="">Futures: In Depth</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/tasks/" class="">Tasks</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/runtime-model/" class="">运行时模型</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/io/" class="">I/O with Tokio</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/chat/" class="">Example: A Chat Server</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/timers/" class="">Timers</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/futures-mechanics/" class="">Essential combinators</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/returning/" class="">Returning futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/frames/" class="">Working with framed streams</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/building-runtime/" class="">Building a runtime</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item active">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/internals/intro/">
                  Tokio 内部原理
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/intro/" class="">Introduction</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/runtime-model/" class="">Runtime model</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/net/" class="active">Non-blocking I/O</a></li>
                
                </ul>
              </div>
            
          
            
              <div class="tk-toc-item">
                <a class="tk-toc-link" href="https://docs.rs/tokio">
                  API 文档
                </a>
              </div>
            
          
      </nav>
    </div>
    <div class="d-none d-xl-block col-xl-2 tk-toc">
      <div class="section-nav">
        <nav id="TableOfContents">
<ul>
<li><a href="#the-network-resource">The network resource.</a>
<ul>
<li><a href="#using-the-resource">Using the resource</a></li>
</ul></li>
<li><a href="#registering-the-resource-with-the-driver">Registering the resource with the driver</a>
<ul>
<li><a href="#handle-current-vs-handle-default"><code>Handle::current</code> vs <code>Handle::default</code></a></li>
</ul></li>
<li><a href="#the-network-driver">The network driver</a>
<ul>
<li><a href="#linking-the-driver-with-resources">Linking the driver with resources</a></li>
<li><a href="#running-the-driver">Running the driver</a></li>
</ul></li>
</ul>
</nav>
      </div>
    </div>
    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 tk-content tk-docs">
      <h1 class="tk-title">Non-blocking I/O</h1>
      <div class="github-edit">
        <a class="fa fa-github" href="https://github.com/hltj/tokio-website-cn/tree/master/content/docs/internals/net.md"> 在 GitHub 上编辑</a>
      </div>
      

<p>This section describes the network resources and drivers provided by Tokio. This
component provides one of Tokio&rsquo;s primary functions: non-blocking, event-driven,
networking provided by the appropriate operating system primitives (epoll,
kqueue, IOCP, &hellip;). It is modeled after the resource and driver pattern
described in the previous section.</p>

<p>The network driver is built using <a href="https://docs.rs/mio/">mio</a> and network resources are backed by
types that implement <a href="https://docs.rs/mio/0.6/mio/event/trait.Evented.html"><code>Evented</code></a>.</p>

<p>This guide will be focused on TCP types. The other network resources (UDP, unix
sockets, pipes, etc) follow the same pattern.</p>

<h1 id="the-network-resource">The network resource.</h1>

<p>Network resources are types, such as <a href="https://docs.rs/tokio/0.1/tokio/net/struct.TcpListener.html"><code>TcpListener</code></a> and <a href="https://docs.rs/tokio/0.1/tokio/net/struct.TcpStream.html"><code>TcpStream</code></a>, that are
composed of the network handle and a reference to the <a href="#the-network-driver">driver</a> that is powering
the resource. Initially, when the resource is first created, the driver pointer
may be <code>None</code>:</p>

<pre><code class="language-rust"># extern crate tokio;
# use tokio::net::TcpListener;
# use std::net::SocketAddr;
# fn dox(addr: SocketAddr) {
let listener = TcpListener::bind(&amp;addr).unwrap();
# }
</code></pre>

<p>In this case, the reference to the driver is not yet set. However, if a
constructor that takes a <a href="https://docs.rs/tokio-reactor/0.1/tokio_reactor/struct.Handle.html"><code>Handle</code></a> reference is used, then the driver reference
will be set to driver represented by the given handle:</p>

<pre><code class="language-rust"># extern crate tokio;
# use tokio::net::TcpListener;
# use tokio::reactor::Handle;
# use std::net::TcpListener as StdListener;
# fn dox(std_listener: StdListener, my_reactor_handle: &amp;Handle) {
let listener = TcpListener::from_std(std_listener, &amp;my_reactor_handle);
# }
</code></pre>

<p>Once a driver is associated with a resource, it is set for the lifetime of the
resource and cannot be changed. The associated driver is responsible for
receiving operating system events for the network resource and notifying the
tasks that have expressed interest in the resource.</p>

<h2 id="using-the-resource">Using the resource</h2>

<p>Resource types include non-blocking functions that are prefixed with <code>poll_</code> and
that include <code>Async</code> in the return type. These are the functions that are linked
with the task system and should be used from tasks and are used as part of
[<code>Future</code>] implementations. For example, <a href="https://docs.rs/tokio/0.1/tokio/net/struct.TcpStream.html"><code>TcpStream</code></a> provides [<code>poll_read</code>] and
[<code>poll_write</code>]. <a href="https://docs.rs/tokio/0.1/tokio/net/struct.TcpListener.html"><code>TcpListener</code></a> provides [<code>poll_accept</code>].</p>

<p>Here is a task that uses [<code>poll_accept</code>] to accept inbound sockets from a
listener and handle them by spawning a new task:</p>

<pre><code class="language-rust,ignore">struct Acceptor {
    listener: TcpListener,
}

impl Future for Acceptor {
    type Item = ();
    type Error = ();

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        loop {
            let (socket, _) = try_ready!(self.listener.poll_accept());

            // Spawn a task to process the socket
            tokio::spawn(process(socket));
        }
    }
}
</code></pre>

<p>Resource types may also include functions that return futures. These are
helpers that use the <code>poll_</code> functions to provide additional functionality. For
example, <a href="https://docs.rs/tokio/0.1/tokio/net/struct.TcpStream.html"><code>TcpStream</code></a> provides a [<code>connect</code>] function that returns a future.
This future will complete once the <a href="https://docs.rs/tokio/0.1/tokio/net/struct.TcpStream.html"><code>TcpStream</code></a> has established a connection
with a peer (or failed attemepting to do so).</p>

<p>Using combinators to connect a <a href="https://docs.rs/tokio/0.1/tokio/net/struct.TcpStream.html"><code>TcpStream</code></a>:</p>

<pre><code class="language-rust,no_run"># extern crate tokio;
# use tokio::prelude::*;
# use tokio::net::TcpStream;
# use std::io;
# fn process&lt;T&gt;(t: T) -&gt; impl Future&lt;Item = (), Error = io::Error&gt; {
#   Ok(()).into_future()
# }
# fn dox() {
# let addr = &quot;127.0.0.1:0&quot;.parse().unwrap();
tokio::spawn({
    let connect_future = TcpStream::connect(&amp;addr);

    connect_future
        .and_then(|socket| process(socket))
        .map_err(|_| panic!())
});
# }
</code></pre>

<p>Futures may also be used directly from other future implementations:</p>

<pre><code class="language-rust,ignore">struct ConnectAndProcess {
    connect: ConnectFuture,
}

impl Future for ConnectAndProcess {
    type Item = ();
    type Error = ();

    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt; {
        let socket = try_ready!(self.connect.poll());
        tokio::spawn(process(socket));
        Ok(Async::Ready(()))
    }
}
</code></pre>

<h1 id="registering-the-resource-with-the-driver">Registering the resource with the driver</h1>

<p>When using <a href="http://docs.rs/tokio/0.1.8/tokio/net/struct.TcpListener.html#method.poll_accept"><code>TcpListener::poll_accept</code></a> (or any <code>poll_*</code> function),
if the resource is ready to return immediately then it will do so. In the case
of <a href="http://docs.rs/tokio/0.1.8/tokio/net/struct.TcpListener.html#method.poll_accept"><code>poll_accept</code></a>, being ready means that there is a socket
waiting to be accepted in the queue. If the resource is <strong>not</strong> ready, i.e.
there is no pending socket to accept, then the resource asks the driver to
notify the current task once it becomes ready.</p>

<p>The first time <code>NotReady</code> is returned by a resource, if the resource was not
explicity assigned a driver using a <a href="https://docs.rs/tokio-reactor/0.1/tokio_reactor/struct.Handle.html"><code>Handle</code></a> argument, the resource will register
itself with a driver instance. This is done by looking at the network driver
associated with the current execution context.</p>

<p>The default driver for the execution context is stored using a thread-local, set
using <a href="https://docs.rs/tokio-reactor/0.1.5/tokio_reactor/fn.with_default.html"><code>with_default</code></a>, and accessed using <a href="https://docs.rs/tokio/0.1/tokio/reactor/struct.Handle.html#method.current"><code>Handle::current</code></a>. It is the
runtime&rsquo;s responsibility to ensure that the task is polled from within the
closure passed to <a href="https://docs.rs/tokio-reactor/0.1.5/tokio_reactor/fn.with_default.html"><code>with_default</code></a>. A call to <a href="https://docs.rs/tokio/0.1/tokio/reactor/struct.Handle.html#method.current"><code>Handle::current</code></a> accesses the
thread-local set by <a href="https://docs.rs/tokio-reactor/0.1.5/tokio_reactor/fn.with_default.html"><code>with_default</code></a> in order to return the handle to the
driver for the current execution context.</p>

<h2 id="handle-current-vs-handle-default"><code>Handle::current</code> vs <code>Handle::default</code></h2>

<p>Both <code>Handle::current</code> and <code>Handle::default</code> return a <code>Handle</code> instance.
They are, however, subtly different. Most often, <code>Handle::default</code> is the
desired behavior.</p>

<p><code>Handle::current</code> <strong>immediately</strong> reads the thread-local variable storing the
driver for the current driver. This means that <code>Handle::current</code> must be called
from an execution context that set the default driver. <code>Handle::current</code> should
be used when the handle is going to be sent to a different execution contexts
and the user wishes that a specific reactor is used (see below for an example).</p>

<p>On the other hand, <a href="https://docs.rs/tokio-reactor/0.1.5/tokio_reactor/struct.Handle.html#method.default"><code>Handle::default</code></a> lazily reads the thread-local variable.
This allows getting a <code>Handle</code> instance from <em>outside</em> of an execution context.
When the resource is used, the handle will access the thread-local variable as
described in the previous section.</p>

<p>For example:</p>

<pre><code class="language-rust,no_run"># extern crate tokio;
# use tokio::prelude::*;
# use tokio::net::TcpListener;
# use tokio::reactor::Handle;
# use std::net::SocketAddr;
# fn process&lt;T&gt;(t: T) -&gt; impl Future&lt;Item = (), Error = ()&gt; {
#   Ok(()).into_future()
# }
fn main() {
    let addr: SocketAddr = &quot;127.0.0.1:0&quot;.parse().unwrap();
    let std_listener = ::std::net::TcpListener::bind(&amp;addr).unwrap();
    let listener = TcpListener::from_std(std_listener, &amp;Handle::default()).unwrap();

    tokio::run({
        listener.incoming().for_each(|socket| {
            tokio::spawn(process(socket));
            Ok(())
        })
        .map_err(|_| panic!(&quot;error&quot;))
    });
}
</code></pre>

<p>In this example, <code>incoming()</code> returns a future that is implemented by calling
<code>poll_accept</code>. The future is spawned onto a runtime, which has a network driver
configured as part of the execution context. When <code>poll_accept</code> is called from
within the execution context, that is when the thread-local is read and the
driver is associated with the <code>TcpListener</code> instance.</p>

<p>However, if <code>tokio-threadpool</code> is used directly, then tasks spawned onto the
threadpool executor will not have access to a reactor:</p>

<pre><code class="language-rust"># extern crate tokio;
# extern crate tokio_threadpool;
# use tokio_threadpool::*;
# use tokio::prelude::*;
# use tokio::net::TcpListener;
# fn dox() {
# let addr = &quot;127.0.0.1:0&quot;.parse().unwrap();
let pool = ThreadPool::new();
let listener = TcpListener::bind(&amp;addr).unwrap();

pool.spawn({
    listener.incoming().for_each(|socket| {
        // This will never get called due to the listener not being able to
        // function.
        unreachable!();
# Ok(())
    })
    .map_err(|_| panic!(&quot;error&quot;))
});
# }
</code></pre>

<p>In order to make the above example work, a reactor must be set for the
threadpool&rsquo;s execution context. See <a href="https://tokio-cn.github.io/docs/going-deeper/building-runtime/">building a runtime</a> for more
details. Alternatively, a <code>Handle</code> obtained with <code>[Handle::current]</code> could be
used:</p>

<pre><code class="language-rust"># extern crate futures;
# extern crate tokio;
# extern crate tokio_threadpool;
# use tokio::prelude::*;
# use tokio::net::TcpListener;
# use tokio_threadpool::*;
# use tokio::reactor::Handle;
# use futures::future;
# use std::net::SocketAddr;
# fn dox() {
# let addr: SocketAddr = &quot;127.0.0.1:0&quot;.parse().unwrap();
let pool = ThreadPool::new();

// This does not run on the pool.
tokio::run(future::lazy(move || {
    // Get the handle
    let handle = Handle::current();

    let std_listener = std::net::TcpListener::bind(&amp;addr).unwrap();

    // This eagerly links the listener with the handle for the current reactor.
    let listener = TcpListener::from_std(std_listener, &amp;handle).unwrap();

    pool.spawn({
        listener.incoming().for_each(|socket| {
            // Do something with the socket
            Ok(())
        })
        .map_err(|_| panic!())
    });

    Ok(())
}));
# }
</code></pre>

<h1 id="the-network-driver">The network driver</h1>

<p>The driver that powers all of Tokio&rsquo;s network types is the [<code>Reactor</code>] type in
the [<code>tokio-reactor</code>] crate. It is implemented using <a href="https://docs.rs/mio/">mio</a>. Calls to
[<code>Reactor::turn</code>] uses [<code>mio::Poll::poll</code>] to get operating system events for
registered network resources. It then notifies the registered tasks for each
network resource using the [task system]. The tasks then get scheduled to run on
their associated executors and the task then sees the network resource as ready
and calls to <code>poll_*</code> functions return <code>Async::Ready</code>.</p>

<h2 id="linking-the-driver-with-resources">Linking the driver with resources</h2>

<p>The driver must track each resource that is registered with it. While the actual
implementation is more complex, it can be thought as a shared reference to a
cell sharing state, similar to:</p>

<pre><code class="language-rust,ignore">struct Registration {
    // The registration needs to know its ID. This allows it to remove state
    // from the reactor when it is dropped.
    id: Id,

    // The task that owns the resource and is registered to receive readiness
    // notifications from the driver.
    //
    // If `task` is `Some`, we **definitely** know that the resource
    // is not ready because we have not yet received an operating system event.
    // This allows avoiding syscalls that will return `NotReady`.
    //
    // If `task` is `None`, then the resource **might** be ready. We can try the
    // syscall, but it might still return `NotReady`.
    task: Option&lt;task::Task&gt;,
}

struct TcpListener {
    mio_listener: mio::TcpListener,
    registration: Option&lt;Arc&lt;Mutex&lt;Registration&gt;&gt;&gt;,
}

struct Reactor {
    poll: mio::Poll,
    resources: HashMap&lt;Id, Arc&lt;Mutex&lt;Registration&gt;&gt;&gt;,
}
</code></pre>

<p><strong>This is not the real implementation</strong>, but a simplified version to demonstrate
the behavior. In practice, there is no <code>Mutex</code>, cells are not allocated per
resource instance, and the reactor does not use a <code>HashMap</code>. The real
implementation can be found <a href="https://github.com/tokio-rs/tokio/blob/master/tokio-reactor/src/lib.rs">here</a></p>

<p>When the resource is first used, it is registered with the driver:</p>

<pre><code class="language-rust,ignore">impl TcpListener {
    fn poll_accept(&amp;mut self) -&gt; Poll&lt;TcpStream, io::Error&gt; {
        // If the registration is not set, this will associate the `TcpListener`
        // with the current execution context's reactor.
        let registration = self.registration.get_or_insert_with(|| {
            // Access the thread-local variable that tracks the reactor.
            Reactor::with_current(|reactor| {
                // Registers the listener, which implements `mio::Evented`.
                // `register` returns the registration instance for the resource.
                reactor.register(&amp;self.mio_listener)
            })
        });

        if registration.task.is_none() {
            // The task is `None`, this means the resource **might** be ready.
            match self.mio_listener.accept() {
                Ok(socket) =&gt; {
                    let socket = mio_socket_to_tokio(socket);
                    return Ok(Async::Ready(socket));
                }
                Err(ref e) if e.kind() == WouldBlock =&gt; {
                    // The resource is not ready, fall through to task registration
                }
                Err(e) =&gt; {
                    // All other errors are returned to the caller
                    return Err(e);
                }
            }
        }

        // The task is set even if it is already `Some`, this handles the case where
        // the resource is moved to a different task than the one stored in
        // `self.task`.
        registration.task = Some(task::current());
        Ok(Async::NotReady)
    }
}
</code></pre>

<p>Note that there is only a single <code>task</code> field per resource. The implications are
that a resource can only be used from a single task at a time. If
<code>TcpListener::poll_accept</code> returns <code>NotReady</code>, registering the current task and
the listener is then sent to a different task which calls <code>poll_accept</code> and sees
<code>NotReady</code>, then the second task is the only one that will receive a
notification once a socket is ready to be accepted. Resources may support
tracking different tasks for different operations. For example, <code>TcpStream</code>
internally has two task fields: one for notifying on read ready and one for
notifying on write ready. This allows <code>TcpStream::poll_read</code> and
<code>TcpStream::poll_write</code> to be called from different tasks.</p>

<p>The evented types are registered with the driver&rsquo;s <a href="https://docs.rs/mio/0.6/mio/struct.Poll.html"><code>mio::Poll</code></a> instance as
part of the <code>register</code> function used above. Again, this guide uses a
<strong>simplified</strong> implementation which does not match the actual one in
<code>tokio-reactor</code> but is sufficient for understanding how <code>tokio-reactor</code> behaves.</p>

<pre><code class="language-rust,ignore">impl Reactor {
    fn register&lt;T: mio::Evented&gt;(&amp;mut self, evented: &amp;T) -&gt; Arc&lt;Mutex&lt;Registration&gt;&gt; {
        // Generate a unique identifier for this registration. This identifier
        // can be converted to and from a Mio Token.
        let id = generate_unique_identifier();

        // Register the I/O type with Mio
        self.poll.register(
            evented, id.into_token(),
            mio::Ready::all(),
            mio::PollOpt::edge());

        let registration = Arc::new(Mutex::new(Registration {
            id,
            task: None,
        }));

        self.resources.insert(id, registration.clone());

        registration
    }
}
</code></pre>

<h2 id="running-the-driver">Running the driver</h2>

<p>The driver needs to run in order for its associated resources to function. If
the driver does not run, the resources will never become ready. Running the
driver is handled automatically when using a <a href="https://docs.rs/tokio/0.1/tokio/runtime/struct.Runtime.html"><code>Runtime</code></a>, but it is useful to
understand how it works. If you are interested in the real implementation, the
<a href="https://github.com/tokio-rs/tokio/blob/master/tokio-reactor/src/lib.rs"><code>tokio-reactor</code></a> source is the best reference.</p>

<p>When resources are registered with the driver, they are also registered with
Mio. Running the driver performs the following steps in a loop:</p>

<p>1) Call <a href="https://docs.rs/mio/0.6/mio/struct.Poll.html#method.poll"><code>Poll::poll</code></a> to get operating system events.
2) Dispatch all events to the appropriate resources via the registration.</p>

<p>The steps above are done by calling <code>Reactor::turn</code>. The looping part is up to
us. This is typically done in a background thread or embedded in the executor as
a <a href="https://docs.rs/tokio-executor/0.1/tokio_executor/park/trait.Park.html"><code>Park</code></a> implementation. See the <a href="https://tokio-cn.github.io/docs/going-deeper/building-runtime/">runtime guide</a> for more details.</p>

<pre><code class="language-rust"># extern crate tokio_reactor;
# fn dox() {
# let mut reactor = tokio_reactor::Reactor::new().unwrap();
loop {
    // `None` means never timeout, blocking until we receive an operating system
    // event.
    reactor.turn(None);
}
# }
</code></pre>

<p>The implementation of <code>turn</code> does the following:</p>

<pre><code class="language-rust,ignore">fn turn(&amp;mut self) {
    // Create storage for operating system events. This shouldn't be created
    // each time `turn` is called, but doing so does not impact behavior.
    let mut events = mio::Events::with_capacity(1024);

    self.poll.poll(&amp;mut events, timeout);

    for event in &amp;events {
        let id = Id::from_token(event.token());

        if let Some(registration) = self.resources.get(&amp;id) {
            if let Some(task) = registration.lock().unwrap().task.take() {
                task.notify();
            }
        }
    }
}
</code></pre>

<p>Notifying the task results in the task getting scheduled on its executor. When
the task runs again, it will call the <code>poll_accept</code> function again. This time,
the <code>task</code> slot will be <code>None</code>. This means the syscall should be attempted, and
this time <code>poll_accept</code> will return an accepted socket (probably, spurious events are permitted).</p>

      
      
    </main>
  </div>
</div>

    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js" integrity="sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8" crossorigin="anonymous"></script>
    <script src="https://tokio-cn.github.io/js/bootstrap.min.js"></script>
    <script src="https://tokio-cn.github.io/js/highlight.js"></script>
    <script>
      $(function () {
        $("pre code").each(function(i, block) {
          
          if (block.className.indexOf('language-rust') >= 0) {
            var new_content = '';
            var lines = block.textContent.split('\n');
            for (var i = 0; i < lines.length; i++) {
              if (lines[i].indexOf('# ') == 0 || lines[i] == '#') {
                continue
              }
              new_content += lines[i].trimRight() + '\n';
            }
            block.textContent = new_content.replace(/\n\n\n/g, "\n\n").trimRight();
          }
          hljs.highlightBlock(block);
        });
      });
    </script>
    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
    <script type="text/javascript"> docsearch({
    apiKey: 'd7b5b785798fe748621bcaa8301a2201',
    indexName: 'tokio',
    inputSelector: '#search-input',
    debug: false 
    });
    </script>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-122396021-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

