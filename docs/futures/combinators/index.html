<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <link rel="apple-touch-icon" sizes="120x120" href="https://tokio-cn.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://tokio-cn.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://tokio-cn.github.io/favicon-16x16.png">
    <link rel="manifest" href="https://tokio-cn.github.io/manifest.json">
    <link rel="mask-icon" href="https://tokio-cn.github.io/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="theme-color" content="#ffffff">

    
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap-reboot.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/tokio.css">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/>

    
    <link rel="alternate" type="application/rss+xml" href="https://tokio-cn.github.io/blog/index.xml" />

    <title>
      
        Combinators · Tokio 中文站
      
    </title>
  </head>
  <body>
    <header class="navbar navbar-expand navbar-dark flex-column flex-md-row tk-navbar">
      <a class="navbar-brand" href="https://tokio-cn.github.io/">
        <img src="https://tokio-cn.github.io/img/Tokio_Mark_White.png" class="align-middle" alt="">
      </a>
      <div class="collapse navbar-collapse">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link " href="https://tokio-cn.github.io/">首页</a>
          </li>
          <li class="nav-item">
            
            
            
            <a class="nav-link  active " href="https://tokio-cn.github.io/docs/getting-started/hello-world/">文档</a>
          </li>
          <li class="nav-item">
            
            <a class="nav-link " href="https://tokio-cn.github.io/community/">社区</a>
          </li>
          <li class="nav-item">
            
            
            <a class="nav-link " href="https://tokio-cn.github.io/blog/2018-12-recap-2018/">博客</a>
          </li>
        </ul>
      </div>

      <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
        <li class="nav-item dropdown">
          <a class="nav-item nav-link dropdown-toggle mr-md-2" href="#" id="tk-langs" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            中文
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="tk-langs">
            <a class="dropdown-item active" href="#">中文</a>
            <a class="dropdown-item" href="https://tokio-zh.github.io/" rel="nofollow">官方中文</a>
            <a class="dropdown-item" href="https://tokio.rs" rel="nofollow">English</a>
          </div>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://github.com/tokio-rs/tokio" target="_blank" rel="noopener" aria-label="GitHub">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 499.36" focusable="false"><title>GitHub</title><path d="M256 0C114.64 0 0 114.61 0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34 0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49 0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75 0 0 21.49-6.88 70.4 26.24a242.65 242.65 0 0 1 128.18 0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69 0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41 0 34.22-.31 61.83-.31 70.23 0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37 0 256 0z" fill="currentColor" fill-rule="evenodd"/></svg>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://twitter.com/tokio_rs" target="_blank" rel="noopener" aria-label="Twitter">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 416.32" focusable="false"><title>Twitter</title><path d="M160.83 416.32c193.2 0 298.92-160.22 298.92-298.92 0-4.51 0-9-.2-13.52A214 214 0 0 0 512 49.38a212.93 212.93 0 0 1-60.44 16.6 105.7 105.7 0 0 0 46.3-58.19 209 209 0 0 1-66.79 25.37 105.09 105.09 0 0 0-181.73 71.91 116.12 116.12 0 0 0 2.66 24c-87.28-4.3-164.73-46.3-216.56-109.82A105.48 105.48 0 0 0 68 159.6a106.27 106.27 0 0 1-47.53-13.11v1.43a105.28 105.28 0 0 0 84.21 103.06 105.67 105.67 0 0 1-47.33 1.84 105.06 105.06 0 0 0 98.14 72.94A210.72 210.72 0 0 1 25 370.84a202.17 202.17 0 0 1-25-1.43 298.85 298.85 0 0 0 160.83 46.92" fill="currentColor"/></svg>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://gitter.im/tokio-rs/tokio" target="_blank" rel="noopener" aria-label="Gitter">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" focusable="false"><title>Gitter</title><path fill="currentColor" d="M8.501 4.001H10.5V24H8.501V4.001zm6.999 0V24h-2V4.001h2zM3.5 0h2.001v15H3.5V0zm15 4.001h2V15h-2V4.001z"/></svg>
          </a>
        </li>
      </ul>
    </header>



<div class="container-fluid tk-docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 tk-sidebar">
      <form class="tk-search d-flex align-items-center">
        <span class="algolia-autocomplete algolia-autocomplete-left" style="position: relative; display: inline-block; direction: ltr;">
          <input class="form-control ds-input" id="search-input" placeholder="搜索……" autocomplete="off" spellcheck="false" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-owns="algolia-autocomplete-listbox-0" style="position: relative; vertical-align: top;" dir="auto" type="search">
          <pre aria-hidden="true" style="position: absolute; visibility: hidden; white-space: pre; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-style: normal; font-variant: normal; font-weight: 400; word-spacing: 0px; letter-spacing: normal; text-indent: 0px; text-rendering: optimizelegibility; text-transform: none;">w</pre>
          <span class="ds-dropdown-menu ds-with-1" style="position: absolute; top: 100%; left: 0px; z-index: 100; right: auto; display: none;" role="listbox" id="algolia-autocomplete-listbox-0">
            <div class="ds-dataset-1"></div>
          </span>
        </span>
        <button class="btn btn-link tk-search-docs-toggle d-md-none p-0 ml-3" type="button" data-toggle="collapse" data-target="#tk-docs-nav" aria-controls="tk-docs-nav" aria-expanded="false" aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false">
            <title>Menu</title><path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"></path></svg>
        </button>
      </form>

      <nav class="tk-links collapse" id="tk-docs-nav">
          
          
            
              <div class="tk-toc-item">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/overview/">
                  Tokio 是什么？
                </a>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/getting-started/hello-world/">
                  入门
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/hello-world/" class="">Hello World!</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/futures/" class="">Futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/runtime/" class="">Runtime</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/echo/" class="">Example: An Echo Server</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item active">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/futures/overview/">
                  使用 future
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/overview/" class="">Overview</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/basic/" class="">Implementing futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/getting_asynchronous/" class="">Getting asynchronous</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/combinators/" class="active">Combinators</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/streams/" class="">Streams</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/spawning/" class="">Spawning</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/leaf-futures/" class="">Leaf futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/runtime-model/" class="">Runtime model</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/io/overview/">
                  使用 Tokio 的 I/O
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/io/overview/" class="">I/O Overview</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/reading_writing_data/" class="">Reading and Writing Data</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/async_read_write/" class="">Using AsyncRead and AsyncWrite directly</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/impl_async_read_write/" class="">Implementing Async Read/Write</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/filesystem/" class="">Filesystem APIs</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/datagrams/" class="">Datagram APIs</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/going-deeper/futures/">
                  深入
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/futures/" class="">Futures: In Depth</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/tasks/" class="">Tasks</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/runtime-model/" class="">运行时模型</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/io/" class="">I/O with Tokio</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/chat/" class="">Example: A Chat Server</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/timers/" class="">Timers</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/futures-mechanics/" class="">Essential combinators</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/returning/" class="">Returning futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/frames/" class="">Working with framed streams</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/building-runtime/" class="">Building a runtime</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/internals/intro/">
                  Tokio 内部原理
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/intro/" class="">Introduction</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/runtime-model/" class="">Runtime model</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/net/" class="">Non-blocking I/O</a></li>
                
                </ul>
              </div>
            
          
            
              <div class="tk-toc-item">
                <a class="tk-toc-link" href="https://docs.rs/tokio">
                  API 文档
                </a>
              </div>
            
          
      </nav>
    </div>
    <div class="d-none d-xl-block col-xl-2 tk-toc">
      <div class="section-nav">
        <nav id="TableOfContents">
<ul>
<li><a href="#building-blocks">Building blocks</a>
<ul>
<li><a href="#map"><code>map</code></a></li>
<li><a href="#and-then"><code>and_then</code></a></li>
</ul></li>
<li><a href="#essential-combinators">Essential combinators</a>
<ul>
<li><a href="#concrete-futures">Concrete futures</a></li>
<li><a href="#intofuture">IntoFuture</a></li>
<li><a href="#adapters">Adapters</a></li>
</ul></li>
<li><a href="#when-to-use-combinators">When to use combinators</a>
<ul>
<li><a href="#functional-style">Functional style</a></li>
<li><a href="#returning-futures">Returning futures</a>
<ul>
<li><a href="#use-impl-future">Use <code>impl Future</code></a>
<ul>
<li><a href="#returning-from-multiple-branches">Returning from multiple branches</a></li>
<li><a href="#associated-types">Associated types</a></li>
</ul></li>
<li><a href="#trait-objects">Trait objects</a></li>
<li><a href="#implement-future-by-hand">Implement <code>Future</code> by hand</a></li>
</ul></li>
<li><a href="#when-to-use-combinators-1">When to use combinators</a></li>
</ul></li>
</ul>
</nav>
      </div>
    </div>
    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 tk-content tk-docs">
      <h1 class="tk-title">Combinators</h1>
      <div class="github-edit">
        <a class="fa fa-github" href="https://github.com/hltj/tokio-website-cn/tree/master/content/docs/futures/combinators.md"> 在 GitHub 上编辑</a>
      </div>
      

<p>Often times, Future implementations follow similar patterns. To help reduce
boilerplate, the <code>futures</code> crate provides a number of utilities, called
&ldquo;combinators&rdquo;, that abstract these patterns. Many of these combinators exist as
functions on the <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>Future</code></a> trait.</p>

<h1 id="building-blocks">Building blocks</h1>

<p>Let&rsquo;s revisit the future implementations from the previous pages and see how
they can be simplified by using combinators.</p>

<h2 id="map"><code>map</code></h2>

<p>The <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.map"><code>map</code></a> combinator takes a future and returns a new future that applies a
function to the value yielded by the first future.</p>

<p>This was the <code>Display</code> future <a href="https://tokio-cn.github.io/docs/futures/basic/#cleaning-things-up"><code>previously</code></a> implemented:</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# #[macro_use]
# extern crate futures;
# extern crate tokio;
#
# use futures::{Future, Async, Poll};
# use std::fmt;
#
# struct Display&lt;T&gt;(T);
#
impl&lt;T&gt; Future for Display&lt;T&gt;
where
    T: Future,
    T::Item: fmt::Display,
{
    type Item = ();
    type Error = T::Error;

    fn poll(&amp;mut self) -&gt; Poll&lt;(), T::Error&gt; {
        let value = try_ready!(self.0.poll());
        println!(&quot;{}&quot;, value);
        Ok(Async::Ready(()))
    }
}

fn main() {
# let HelloWorld = futures::future::ok::&lt;_, ()&gt;(&quot;hello&quot;);
    let future = Display(HelloWorld);
    tokio::run(future);
}
</code></pre>

<p>With the <code>map</code> combinator, it becomes:</p>

<pre><code class="language-rust"># #![deny(deprecated)]
extern crate tokio;
extern crate futures;

use futures::Future;

fn main() {
# let HelloWorld = futures::future::ok::&lt;_, ()&gt;(&quot;hello&quot;);
    let future = HelloWorld.map(|value| {
        println!(&quot;{}&quot;, value);
    });

    tokio::run(future);
}
</code></pre>

<p>This is how <code>map</code> is implemented:</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# #[macro_use]
# extern crate futures;
# use futures::{Future, Async, Poll};
pub struct Map&lt;A, F&gt; where A: Future {
    future: A,
    f: Option&lt;F&gt;,
}

impl&lt;U, A, F&gt; Future for Map&lt;A, F&gt;
    where A: Future,
          F: FnOnce(A::Item) -&gt; U,
{
    type Item = U;
    type Error = A::Error;

    fn poll(&amp;mut self) -&gt; Poll&lt;U, A::Error&gt; {
        let value = try_ready!(self.future.poll());
        let f = self.f.take().expect(&quot;cannot poll Map twice&quot;);

        Ok(Async::Ready(f(value)))
    }
}
# fn main() {}
</code></pre>

<p>Comparing <code>Map</code> with our <code>Display</code> implementation, it is clear how they both are
very similar. Where <code>Display</code> calls <code>println!</code>, <code>Map</code> passes the value to the
function.</p>

<h2 id="and-then"><code>and_then</code></h2>

<p>Now, let&rsquo;s use combinators to rewrite the future that established a TCP stream
and wrote &ldquo;hello world&rdquo; to the peer using the <code>and_then</code> combinator.</p>

<p>The <code>and_then</code> combinator allows sequencing two asynchronous operations. Once
the first operation completes, the value is passed to a function. The function
uses that value to produce a new future and that future is then executed. The
difference between <code>and_then</code> and <code>map</code> is that <code>and_then</code>&rsquo;s function returns a
future where as <code>map</code>&rsquo;s function returns a value.</p>

<p>The original implementation is found <a href="https://tokio-cn.github.io/docs/futures/getting_asynchronous/#chaining-computations">here</a>. Once updated to
use combinators, it becomes:</p>

<pre><code class="language-rust"># #![deny(deprecated)]
extern crate tokio;
extern crate bytes;
extern crate futures;

use tokio::io;
use tokio::net::TcpStream;
use futures::Future;

fn main() {
    let addr = &quot;127.0.0.1:1234&quot;.parse().unwrap();

    let future = TcpStream::connect(&amp;addr)
        .and_then(|socket| {
            io::write_all(socket, b&quot;hello world&quot;)
        })
        .map(|_| println!(&quot;write complete&quot;))
        .map_err(|_| println!(&quot;failed&quot;));

#    let future = futures::future::ok::&lt;(), ()&gt;(());

    tokio::run(future);
}
</code></pre>

<p>Further computations may be sequenced by chaining calls to <code>and_then</code>. For
example:</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# extern crate tokio;
# extern crate bytes;
# extern crate futures;
#
# use tokio::io;
# use tokio::net::TcpStream;
# use futures::Future;

fn main() {
    let addr = &quot;127.0.0.1:1234&quot;.parse().unwrap();

    let future = TcpStream::connect(&amp;addr)
        .and_then(|socket| {
            io::write_all(socket, b&quot;hello world&quot;)
        })
        .and_then(|(socket, _)| {
            // read exactly 11 bytes
            io::read_exact(socket, vec![0; 11])
        })
        .and_then(|(socket, buf)| {
            println!(&quot;got {:?}&quot;, buf);
            Ok(())
        });

# let future = futures::future::ok::&lt;(), ()&gt;(());
    tokio::run(future);
}
</code></pre>

<p>The future returned by <code>and_then</code> executes identically to the future we
implemented by hand on the previous page.</p>

<h1 id="essential-combinators">Essential combinators</h1>

<p>It is worth spending some time with the <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>Future</code> trait</a> and
<a href="https://docs.rs/futures/0.1/futures/future/index.html">module</a> documentation to gain familiarity with the full set of
available combinators. This guide will provide a very quick overview.</p>

<h2 id="concrete-futures">Concrete futures</h2>

<p>Any value can be turned into an immediately complete future. There are a few
functions in the <code>future</code> module for creating such a future:</p>

<ul>
<li><a href="https://docs.rs/futures/0.1/futures/future/fn.ok.html"><code>ok</code></a>, analogous to <code>Result::Ok</code>, converts the provided value into a
immediately ready future that yields back the value.</li>
<li><a href="https://docs.rs/futures/0.1/futures/future/fn.err.html"><code>err</code></a>, analogous to <code>Result::Err</code>, converts the provided error into an
immediately ready future that fails with the error.  as an immediately failed
future.</li>
<li><a href="https://docs.rs/futures/0.1/futures/future/fn.result.html"><code>result</code></a> lifts a result to an immediately complete future.</li>
</ul>

<p>In addition, there is also a function, <a href="https://docs.rs/futures/0.1/futures/future/fn.lazy.html"><code>lazy</code></a>, which allows constructing a
future given a <em>closure</em>. The closure is not immediately invoked, instead it is
invoked the first time the future is polled.</p>

<h2 id="intofuture">IntoFuture</h2>

<p>A crucial API to know about is the <a href="https://docs.rs/futures/0.1/futures/future/trait.IntoFuture.html"><code>IntoFuture</code></a> trait, which is a trait for
values that can be converted into futures. Most APIs that you think of as taking
futures actually work with this trait instead. The key reason: the trait is
implemented for <code>Result</code>, allowing you to return <code>Result</code> values in many places
that futures are expected.</p>

<p>Most combinator closures that return a future actually return an instance of
<a href="https://docs.rs/futures/0.1/futures/future/trait.IntoFuture.html"><code>IntoFuture</code></a>.</p>

<h2 id="adapters">Adapters</h2>

<p>Like <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>, the <code>Future</code> trait includes a broad range of &ldquo;adapter&rdquo;
methods. These methods all consume the future, returning a new future providing
the requested behavior. Using these adapter combinators, it is possible to:</p>

<ul>
<li>Change the type of a future (<a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.map"><code>map</code></a>, <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.map_err"><code>map_err</code></a>)</li>
<li>Run another future after one has completed (<a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.then"><code>then</code></a>, <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then"><code>and_then</code></a>,
<a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.or_else"><code>or_else</code></a>)</li>
<li>Figure out which of two futures resolves first (<a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.select"><code>select</code></a>)</li>
<li>Wait for two futures to both complete (<a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.join"><code>join</code></a>)</li>
<li>Convert to a trait object (<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new"><code>Box::new</code></a>)</li>
<li>Convert unwinding into errors (<a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.catch_unwind"><code>catch_unwind</code></a>)</li>
</ul>

<h1 id="when-to-use-combinators">When to use combinators</h1>

<p>Using combinators can reduce a lot of boilerplate, but they are not always a
good fit. Due to limitations, implementing <code>Future</code> manually is going to be common.</p>

<h2 id="functional-style">Functional style</h2>

<p>Closures passed to combinators must be <code>'static</code>. This means it is not possible
to pass references into the closure. Ownership of all state must be moved into
the closure. The reason for this is that lifetimes are based on the stack. With
asynchronous code, the ability to rely on the stack is lost.</p>

<p>Because of this, code written using combinators end up being very functional in
style. Let&rsquo;s compare Future combinators with synchronous <code>Result</code> combinators.</p>

<pre><code class="language-rust">use std::io;

# struct Data;

fn get_data() -&gt; Result&lt;Data, io::Error&gt; {
#     unimplemented!();
    // ...
}

fn get_ok_data() -&gt; Result&lt;Vec&lt;Data&gt;, io::Error&gt; {
    let mut dst = vec![];

    for _ in 0..10 {
        get_data().and_then(|data| {
            dst.push(data);
            Ok(())
        });
    }

    Ok(dst)
}

# fn main() {}
</code></pre>

<p>This works because the closure passed to <code>and_then</code> is able to obtain a mutable
borrow to <code>dst</code>. The Rust compiler is able to guarantee that <code>dst</code> will outlive
the closure.</p>

<p>However, when using futures, it is no longer possible to borrow <code>dst</code>. Instead,
<code>dst</code> must be passed around. Something like:</p>

<pre><code class="language-rust">extern crate futures;

use futures::{stream, Future, Stream};
use std::io;

# struct Data;

fn get_data() -&gt; impl Future&lt;Item = Data, Error = io::Error&gt; {
# futures::future::ok(Data)
    // ...
}

fn get_ok_data() -&gt; impl Future&lt;Item = Vec&lt;Data&gt;, Error = io::Error&gt; {
    let mut dst = vec![];

    // Start with an unbounded stream that uses unit values.
    stream::repeat(())
        // Only take 10. This is how the for loop is simulated using a functional
        // style.
        .take(10)
        // The `fold` combinator is used here because, in order to be
        // functional, the state must be moved into the combinator. In this
        // case, the state is the `dst` vector.
        .fold(dst, move |mut dst, _| {
            // Once again, the `dst` vector must be moved into the nested
            // closure.
            get_data().and_then(move |item| {
                dst.push(item);

                // The state must be included as part of the return value, so
                // `dst` is returned.
                Ok(dst)
            })
        })
}
# fn main() {}
</code></pre>

<p>Another strategy, which tends to work best with immutable data, is to store the
data in an <code>Arc</code> and clone handles into the closures. One case in which this
works well is sharing configuration values in multiple closures. For example:</p>

<pre><code class="language-rust">extern crate futures;

use futures::{future, Future};
use std::io;
use std::sync::Arc;

fn get_message() -&gt; impl Future&lt;Item = String, Error = io::Error&gt; {
    // ....
# futures::future::ok(&quot;&quot;.to_string())
}

fn print_multi() -&gt; impl Future&lt;Item = (), Error = io::Error&gt; {
    let name = Arc::new(&quot;carl&quot;.to_string());

    let futures: Vec&lt;_&gt; = (0..10).map(|_| {
        // Clone the `name` handle, this allows multiple concurrent futures
        // to access the name to print.
        let name = name.clone();

        get_message()
            .and_then(move |message| {
                println!(&quot;Hello {}, {}&quot;, name, message);
                Ok(())
            })
    })
    .collect();

    future::join_all(futures)
        .map(|_| ())
}

# fn main() {}
</code></pre>

<h2 id="returning-futures">Returning futures</h2>

<p>Because combinators often use closures as part of their type signature, it is
not possible to name the future type. This, in turn, means that the future type
cannot be used as part of a function&rsquo;s signature. When passing a future as a
function argument, generics can be used in almost all cases. For example:</p>

<pre><code class="language-rust">extern crate futures;

use futures::Future;

fn get_message() -&gt; impl Future&lt;Item = String&gt; {
    // ...
# futures::future::ok::&lt;_, ()&gt;(&quot;&quot;.to_string())
}

fn with_future&lt;T: Future&lt;Item = String&gt;&gt;(f: T) {
    // ...
# drop(f);
}

# fn main() {
let my_future = get_message().map(|message| {
    format!(&quot;MESSAGE = {}&quot;, message)
});

with_future(my_future);
# }
</code></pre>

<p>However, for returning futures, it isn&rsquo;t as simple. There are a few options with
pros and cons:</p>

<ul>
<li><a href="#use-impl-future">Use <code>impl Future</code></a></li>
<li><a href="#trait-objects">Trait objects</a></li>
<li><a href="#implement-future-by-hand">Implement <code>Future</code> by hand</a></li>
</ul>

<h3 id="use-impl-future">Use <code>impl Future</code></h3>

<p>As of Rust version <strong>1.26</strong>, the language feature <a href="https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md"><code>impl Trait</code></a> can be used for
returning combinator futures. This allows writing the following:</p>

<pre><code class="language-rust"># extern crate futures;
# use futures::Future;
fn add_10&lt;F&gt;(f: F) -&gt; impl Future&lt;Item = i32, Error = F::Error&gt;
    where F: Future&lt;Item = i32&gt;,
{
    f.map(|i| i + 10)
}

# fn main() {}
</code></pre>

<p>The <code>add_10</code> function has a return type that is &ldquo;something that implements
<code>Future</code>&rdquo; with the specified associated types. This allows returning a future
without explicitly naming the future type.</p>

<p>The pros to this approach are that it is zero overhead and covers a wide variety
of cases. However, there is a problem when returning futures from different
code branches. For example:</p>

<pre><code class="language-rust,ignore">if some_condition {
    return get_message()
        .map(|message| format!(&quot;MESSAGE = {}&quot;, message));
} else {
    return futures::ok(&quot;My MESSAGE&quot;.to_string());
}
</code></pre>

<h4 id="returning-from-multiple-branches">Returning from multiple branches</h4>

<p>This results in <code>rustc</code> outputting a compilation error of <code>error[E0308]: if and
else have incompatible types</code>. Functions returning <code>impl Future</code> must still have
a single return type. The <code>impl Future</code> syntax just means that the return type
does not have to be named. However, each combinator type has a <strong>different</strong>
type, so the types being returned in each conditional branch are different.</p>

<p>Given the above scenario, there are two options. The first is to change the
function to return a <a href="#trait-objects">trait object</a>. The second is to use the
<a href="https://docs.rs/futures/0.1.25/futures/future/enum.Either.html"><code>Either</code></a> type:</p>

<pre><code class="language-rust"># extern crate futures;
# use futures::Future;
# use futures::future::{self, Either};
# fn get_message() -&gt; impl Future&lt;Item = String&gt; {
# future::ok::&lt;_, ()&gt;(&quot;&quot;.to_string())
# }
# fn my_op() -&gt; impl Future&lt;Item = String&gt; {
# let some_condition = true;
if some_condition {
    return Either::A(get_message()
        .map(|message| format!(&quot;MESSAGE = {}&quot;, message)));
} else {
    return Either::B(
        future::ok(&quot;My MESSAGE&quot;.to_string()));
}
# }
# fn main() {}
</code></pre>

<p>This ensures that the function has a single return type: <code>Either</code>.</p>

<p>In situations where there are more than two branches, <code>Either</code> enums must be
nested (<code>Either&lt;Either&lt;A, B&gt;, C&gt;</code>) or a custom, multi variant, enum is defined.</p>

<p>This scenario comes up often when trying to conditional return errors.
Consider:</p>

<pre><code class="language-rust"># extern crate futures;
# use futures::{future::{self, Either}, Future};
# fn is_valid(_: &amp;str) -&gt; bool { true }
# fn get_message() -&gt; impl Future&lt;Item = String, Error = &amp;'static str&gt; { future::ok(&quot;&quot;.to_string()) }
fn my_operation(arg: String) -&gt; impl Future&lt;Item = String&gt; {
    if is_valid(&amp;arg) {
        return Either::A(get_message().map(|message| {
            format!(&quot;MESSAGE = {}&quot;, message)
        }));
    }

    Either::B(future::err(&quot;something went wrong&quot;))
}
# fn main() {}
</code></pre>

<p>In order to return early when an error has been encountered, an <code>Either</code> variant
must be used to contain the error future.</p>

<h4 id="associated-types">Associated types</h4>

<p>Traits with functions that return futures must include an associated type for
that future. For example, consider a simplified version of the Tower <a href="https://docs.rs/tower-service/0.1/tower_service/trait.Service.html"><code>Service</code></a>
trait:</p>

<pre><code class="language-rust,ignore">pub trait Service {
    /// Requests handled by the service.
    type Request;

    /// Responses given by the service.
    type Response;

    /// Errors produced by the service.
    type Error;

    /// The future response value.
    type Future: Future&lt;Item = Self::Response, Error = Self::Error&gt;;

    fn call(&amp;mut self, req: Self::Request) -&gt; Self::Future;
}
</code></pre>

<p>In order to implement this trait, the future returned by <code>call</code> must be
nameable and set to the <code>Future</code> associated type. In this case, <code>impl Future</code>
does not work and the future must either be boxed as a <a href="#trait-objects">trait
object</a> or a custom future must be defined.</p>

<h3 id="trait-objects">Trait objects</h3>

<p>Another strategy is to return a boxed future as a <a href="https://doc.rust-lang.org/book/trait-objects.html">trait object</a>:</p>

<pre><code class="language-rust"># extern crate futures;
# use std::io;
# use futures::Future;
# fn main() {}
fn foo() -&gt; Box&lt;Future&lt;Item = u32, Error = io::Error&gt; + Send&gt; {
    // ...
# loop {}
}
</code></pre>

<p>The pro of this strategy is that it is easy to write <code>Box</code>. It also is able to
handle the &ldquo;branching&rdquo; described above with arbitrary number of branches:</p>

<pre><code class="language-rust"># extern crate futures;
# use futures::{future::{self, Either}, Future};
# fn is_valid(_: &amp;str) -&gt; bool { true }
# fn get_message() -&gt; impl Future&lt;Item = String, Error = &amp;'static str&gt; { future::ok(&quot;&quot;.to_string()) }
fn my_operation(arg: String) -&gt; Box&lt;Future&lt;Item = String, Error = &amp;'static str&gt; + Send&gt; {
    if is_valid(&amp;arg) {
        if arg == &quot;foo&quot; {
            return Box::new(get_message().map(|message| {
                format!(&quot;FOO = {}&quot;, message)
            }));
        } else {
            return Box::new(get_message().map(|message| {
                format!(&quot;MESSAGE = {}&quot;, message)
            }));
        }
    }

    Box::new(future::err(&quot;something went wrong&quot;))
}
# fn main() {}
</code></pre>

<p>The downside is that the boxing approach requires more overhead. An allocation
is required to store the returned future value. In addition, whenever the future
is used Rust needs to dynamically unbox it via a runtime lookup (vtable).
This can make boxed futures slightly slower in practice, though the difference
is often not noticeable.</p>

<p>There is one caveat that can trip up authors trying to use a <code>Box&lt;Future&lt;...&gt;&gt;</code>,
particularly with <code>tokio::run</code>. By default, <code>Box&lt;Future&lt;...&gt;&gt;</code> is <strong>not</strong> <code>Send</code>
and cannot be sent across threads, <strong>even if the future contained in the box is
<code>Send</code></strong>.</p>

<p>To make a boxed future <code>Send</code>, it must be annotated as such:</p>

<pre><code class="language-rust,ignore">fn my_operation() -&gt; Box&lt;Future&lt;Item = String, Error = &amp;'static str&gt; + Send&gt; {
    // ...
}
</code></pre>

<h3 id="implement-future-by-hand">Implement <code>Future</code> by hand</h3>

<p>Finally, when the above strategies fail, it is always possible to fall back on
implementing <code>Future</code> by hand. Doing so provides full control, but comes at a
cost of additional boilerplate given that no combinator functions can be used
with this approach.</p>

<h2 id="when-to-use-combinators-1">When to use combinators</h2>

<p>Combinators are powerful ways to reduce boilerplate in your Tokio based
application, but as discussed in this section, they are not a silver bullet. It
is common to implement custom futures as well as custom combinators. This raises
the question of when combinators should be used versus implementing <code>Future</code> by
hand.</p>

<p>As per the discussion above, if the future type must be nameable and a <code>Box</code> is
not acceptable overhead, then combinators may not be used. Besides this, it
depends on the complexity of the state that must be passed around between
combinators.</p>

<p>Scenarios when the state must be accessed concurrently from multiple combinators
may be a good case for implementing a <code>Future</code> by hand.</p>

<p>TODO: This section needs to be expanded with examples. If you have ideas to
improve this section, visit the <a href="https://github.com/tokio-rs/doc-push">doc-push</a> repo and open an issue with your
thoughts.</p>

      
      
        <div class="tk-next">
          <b>下一篇</b>：<a href ="/docs/futures/streams/">Streams</a>
        </div>
      
    </main>
  </div>
</div>

    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js" integrity="sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8" crossorigin="anonymous"></script>
    <script src="https://tokio-cn.github.io/js/bootstrap.min.js"></script>
    <script src="https://tokio-cn.github.io/js/highlight.js"></script>
    <script>
      $(function () {
        $("pre code").each(function(i, block) {
          
          if (block.className.indexOf('language-rust') >= 0) {
            var new_content = '';
            var lines = block.textContent.split('\n');
            for (var i = 0; i < lines.length; i++) {
              if (lines[i].indexOf('# ') == 0 || lines[i] == '#') {
                continue
              }
              new_content += lines[i].trimRight() + '\n';
            }
            block.textContent = new_content.replace(/\n\n\n/g, "\n\n").trimRight();
          }
          hljs.highlightBlock(block);
        });
      });
    </script>
    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
    <script type="text/javascript"> docsearch({
    apiKey: 'd7b5b785798fe748621bcaa8301a2201',
    indexName: 'tokio',
    inputSelector: '#search-input',
    debug: false 
    });
    </script>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-122396021-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

