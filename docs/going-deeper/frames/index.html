<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <link rel="apple-touch-icon" sizes="120x120" href="https://tokio-cn.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://tokio-cn.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://tokio-cn.github.io/favicon-16x16.png">
    <link rel="manifest" href="https://tokio-cn.github.io/manifest.json">
    <link rel="mask-icon" href="https://tokio-cn.github.io/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="theme-color" content="#ffffff">

    
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap-reboot.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/tokio.css">

    
    <link rel="alternate" type="application/rss+xml" href="https://tokio-cn.github.io/blog/index.xml" />

    <title>Working with framed streams</title>
  </head>
  <body>
    <header class="navbar navbar-light navbar-toggleable-md bd-navbar">
      <nav class="tk-main-nav">
        <div class="d-flex justify-content-between hidden-lg-up">
            <a href="https://tokio-cn.github.io/" class="navbar-brand">
              <img src="https://tokio-cn.github.io/img/logo.png" class="align-middle" alt="">
            </a>
            <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#tk-main-nav" aria-label="Toggle navigation" aria-controls="tk-main-nav" aria-expanded="false">
              <span class="navbar-toggler-icon"></span>
            </button>
        </div>
        <div class="navbar-collapse collapse" id="tk-main-nav">
          <ul class="nav navbar-nav">
            <li class="nav-item hd-lg-down">
              <a class="navbar-brand" href="https://tokio-cn.github.io/"><img src="https://tokio-cn.github.io/img/logo.png" class="align-middle" alt=""></a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="https://tokio-cn.github.io/">首页 <span class="sr-only">(current)</span></a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="https://tokio-cn.github.io/docs/getting-started/hello-world/">文档</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="https://tokio-cn.github.io/community/">社区</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="https://tokio-cn.github.io/blog/2018-05-tokio-fs/">博客</a>
            </li>
          </ul>
        </div>
      </nav>
    </header>



<div class="tk-pageheader">
  <div class="container">
    <h1 class="display-4">Working with framed streams</h1>
    <p class="lead">Understanding tokio helpers for framed streams</p>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-3">

      <nav class="leftnav">
        <div class="" id="">
          <h5>入门</h5>
          <hr/>

          <div class="" id="">
            <ul class="nav">
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/getting-started/hello-world/" class="text-muted">Hello World!</a>
              </li>
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/getting-started/runtime-model/" class="text-muted">Runtime Model</a>
              </li>
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/getting-started/futures/" class="text-muted">Futures</a>
              </li>
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/getting-started/tasks/" class="text-muted">Tasks</a>
              </li>
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/getting-started/io/" class="text-muted">I/O with Tokio</a>
              </li>
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/getting-started/chat/" class="text-muted">Example: A Chat Server</a>
              </li>
              
            </ul>
          </div>

          <h5>深入</h5>
          <hr/>

          <div class="" id="">
            <ul class="nav">
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/going-deeper/timers/" class="text-muted">Timers</a>
              </li>
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/going-deeper/futures-mechanics/" class="text-muted">Essential combinators</a>
              </li>
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/going-deeper/returning/" class="text-muted">Returning futures</a>
              </li>
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/going-deeper/frames/" >Working with framed streams</a>
              </li>
              
              <li class="active">
                <a href="https://tokio-cn.github.io/docs/going-deeper/building-runtime/" class="text-muted">Building a runtime</a>
              </li>
              
            </ul>
          </div>

          <br/>
          <h5>参考</h5>
          <hr/>

          <div class="" id="">
            <ul class="nav">
              <li class="active">
                <a href="https://docs.rs/tokio" class="text-muted"><code>tokio</code> API 文档</a>
              </li>
              <li class="active">
                <a href="https://docs.rs/futures/0.1" class="text-muted"><code>futures</code> API 文档</a>
              </li>
            </ul>
          </div>
        </div>
      </nav>

    </div>
    <div class="col-md-9">
      <div class="tk-content">
        <div class="github-edit">
            <a class="fa fa-github" href="https://github.com/hltj/tokio-website-cn/tree/master/content/docs/going-deeper/frames.md"> 在 GitHub 上编辑</a>
        </div>
        

<p>Tokio has helpers to transform a stream of bytes into a stream of frames. Examples
of byte streams include TCP connections, pipes, file objects and the standard
input and output file descriptors. In Rust, streams are easily identified
because they implement the <code>Read</code> and <code>Write</code> traits.</p>

<p>One of the simplest forms of framed message is the line delimited message.
Each message ends with a <code>\n</code> character. Let&rsquo;s look at how one would implement
a stream of line delimited messages with tokio.</p>

<h2 id="writing-a-codec">Writing a codec</h2>

<p>The codec implements the <code>tokio_codec::Decoder</code> and
<code>tokio_codec::Encoder</code> traits. Its job is to convert a frame to and from
bytes. Those traits are used in conjunction with the <code>tokio_codec::Framed</code>
struct to provide buffering, decoding and encoding of byte streams.</p>

<p>Let&rsquo;s look at a simplified version of the <code>LinesCodec</code> struct, which implements
decoding and encoding of the line delimited message.</p>

<pre><code class="language-rust">pub struct LinesCodec {
    // Stored index of the next index to examine for a `\n` character.
    // This is used to optimize searching.
    // For example, if `decode` was called with `abc`, it would hold `3`,
    // because that is the next index to examine.
    // The next time `decode` is called with `abcde\n`, the method will
    // only look at `de\n` before returning.
    next_index: usize,
}
</code></pre>

<p>The comments here explain how, since the bytes are buffered until a line is
found, it is wasteful to search for a <code>\n</code> from the beginning of the buffer
everytime data is received. It&rsquo;s more efficient to keep the last length of
the buffer and start searching from there when new data is received.</p>

<p>The <code>Decoder::decode</code> method is called when data is received on the underlying
stream. The method can produce a frame or return <code>Ok(None)</code> to signify that
it needs more data to produce a frame. The <code>decode</code> method is responsible
for removing the data that no longer needs to be buffered by splitting it off
using the <code>BytesMut</code> methods. If the data is not removed, the buffer will
keep growing.</p>

<p>Let&rsquo;s look at how <code>Decoder::decode</code> is implemented for <code>LinesCodec</code>.</p>

<pre><code class="language-rust"># extern crate bytes;
# extern crate tokio_io;
# use std::io;
# use std::str;
# use bytes::BytesMut;
# use tokio_io::codec::*;
# struct LinesCodec { next_index: usize };
# impl Decoder for LinesCodec {
#    type Item = String;
#    type Error = io::Error;
fn decode(&amp;mut self, buf: &amp;mut BytesMut) -&gt; Result&lt;Option&lt;String&gt;, io::Error&gt; {
    // Look for a byte with the value '\n' in buf. Start searching from the search start index.
    if let Some(newline_offset) = buf[self.next_index..].iter().position(|b| *b == b'\n')
    {
        // Found a '\n' in the string.

        // The index of the '\n' is at the sum of the start position + the offset found.
        let newline_index = newline_offset + self.next_index;

        // Split the buffer at the index of the '\n' + 1 to include the '\n'.
        // `split_to` returns a new buffer with the contents up to the index.
        // The buffer on which `split_to` is called will now start at this index.
        let line = buf.split_to(newline_index + 1);

        // Trim the `\n` from the buffer because it's part of the protocol,
        // not the data.
        let line = &amp;line[..line.len() - 1];

        // Convert the bytes to a string and panic if the bytes are not valid utf-8.
        let line = str::from_utf8(&amp;line).expect(&quot;invalid utf8 data&quot;);

        // Set the search start index back to 0.
        self.next_index = 0;

        // Return Ok(Some(...)) to signal that a full frame has been produced.
        Ok(Some(line.to_string()))
    } else {
        // '\n' not found in the string.

        // Tell the next call to start searching after the current length of the buffer
        // since all of it was scanned and no '\n' was found.
        self.next_index = buf.len();

        // Ok(None) signifies that more data is needed to produce a full frame.
        Ok(None)
    }
}
# }
</code></pre>

<p>The <code>Encoder::encode</code> method is called when a frame must be written to the
underlying stream. The frame must be written to the buffer received as a
parameter. The data written to the buffer will be written to the
stream as it becomes ready to send the data.</p>

<p>Let&rsquo;s now look at how <code>Encoder::encode</code> is implemented for <code>LinesCodec</code>.</p>

<pre><code class="language-rust"># extern crate bytes;
# extern crate tokio_io;
# use std::io;
# use std::str;
# use bytes::*;
# use tokio_io::codec::*;
# struct LinesCodec { next_index: usize };
# impl Encoder for LinesCodec {
#    type Item = String;
#    type Error = io::Error;
fn encode(&amp;mut self, line: String, buf: &amp;mut BytesMut) -&gt; Result&lt;(), io::Error&gt; {
    // It's important to reserve the amount of space needed. The `bytes` API
    // does not grow the buffers implicitly.
    // Reserve the length of the string + 1 for the '\n'.
    buf.reserve(line.len() + 1);

    // String implements IntoBuf, a trait used by the `bytes` API to work with
    // types that can be expressed as a sequence of bytes.
    buf.put(line);

    // Put the '\n' in the buffer.
    buf.put_u8(b'\n');

    // Return ok to signal that no error occured.
    Ok(())
}
# }
</code></pre>

<p>It&rsquo;s often simpler to encode information. Here we simply reserve the space
needed and write the data to the buffer.</p>

<h2 id="using-a-codec">Using a codec</h2>

<p>The simplest way of using a codec is with the <code>Framed</code> struct. It&rsquo;s a wrapper
around a codec that implements automatic buffering. The <code>Framed</code> struct is both
a <code>Stream</code> and a <code>Sink</code>. Thus, you can receive frames from it and send frames
to it.</p>

<p>You can create a <code>Framed</code> struct using any type that implements the <code>AsyncRead</code>
and <code>AsyncWrite</code> traits using the <code>AsyncRead::framed</code> method.</p>

<pre><code class="language-rust"># extern crate futures;
# extern crate tokio;
# extern crate tokio_codec;
# use futures::prelude::*;
# use tokio::net::TcpStream;
# use tokio_codec::{Framed, LinesCodec};
# let addr = &quot;127.0.0.1:5000&quot;.parse().expect(&quot;invalid socket address&quot;);
TcpStream::connect(&amp;addr).and_then(|sock| {
    let framed_sock = Framed::new(sock, LinesCodec::new());
    framed_sock.for_each(|line| {
        println!(&quot;Received line {}&quot;, line);
        Ok(())
    })
});
</code></pre>

        
        <div class="tk-next"><b>Next up</b>: <a href = /docs/going-deeper/building-runtime/>
         Building a runtime</a></div>
      </div>
    </div>
  </div>
</div>

    <footer class="tk-footer">
      <div class="text-muted tk-footer-gray d-flex justify-content-between">
        <div class="tk-footer-info">
          版权所有 © 2018 <a href="https://tokio.rs">Tokio 项目（作）</a> & <a href="https://hltj.me">灰蓝天际（译）</a>
        </div>
        <div class="tk-footer-social">
          <a href="https://twitter.com/tokio_rs" class="text-muted"><i class="fa fa-twitter" aria-hidden="true"></i></a>
          <a href="https://github.com/tokio-rs/tokio" class="text-muted"><i class="fa fa-github" aria-hidden="true"></i></a>
        </div>
      </div>
    </footer>

    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js" integrity="sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8" crossorigin="anonymous"></script>
    <script src="https://tokio-cn.github.io/js/bootstrap.min.js"></script>
    <script src="https://tokio-cn.github.io/js/highlight.js"></script>
    <script>
      $(function () {
        $("pre code").each(function(i, block) {
          
          if (block.className.indexOf('language-rust') >= 0) {
            var new_content = '';
            var lines = block.textContent.split('\n');
            for (var i = 0; i < lines.length; i++) {
              if (lines[i].indexOf('# ') == 0 || lines[i] == '#') {
                continue
              }
              new_content += lines[i].trimRight() + '\n';
            }
            block.textContent = new_content.replace(/\n\n\n/g, "\n\n").trimRight();
          }
          hljs.highlightBlock(block);
        });
      });
    </script>
    
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-122396021-1', 'auto');
ga('send', 'pageview');
</script>

  </body>
</html>

