<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <link rel="apple-touch-icon" sizes="120x120" href="https://tokio-cn.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://tokio-cn.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://tokio-cn.github.io/favicon-16x16.png">
    <link rel="manifest" href="https://tokio-cn.github.io/manifest.json">
    <link rel="mask-icon" href="https://tokio-cn.github.io/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="theme-color" content="#ffffff">

    
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap-reboot.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/bootstrap.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://tokio-cn.github.io/css/tokio.css">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/>

    
    <link rel="alternate" type="application/rss+xml" href="https://tokio-cn.github.io/blog/index.xml" />

    <title>
      
        Tasks · Tokio 中文站
      
    </title>
  </head>
  <body>
    <header class="navbar navbar-expand navbar-dark flex-column flex-md-row tk-navbar">
      <a class="navbar-brand" href="https://tokio-cn.github.io/">
        <img src="https://tokio-cn.github.io/img/Tokio_Mark_White.png" class="align-middle" alt="">
      </a>
      <div class="collapse navbar-collapse">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link " href="https://tokio-cn.github.io/">首页</a>
          </li>
          <li class="nav-item">
            
            
            
            <a class="nav-link  active " href="https://tokio-cn.github.io/docs/getting-started/hello-world/">文档</a>
          </li>
          <li class="nav-item">
            
            <a class="nav-link " href="https://tokio-cn.github.io/community/">社区</a>
          </li>
          <li class="nav-item">
            
            
            <a class="nav-link " href="https://tokio-cn.github.io/blog/2018-10-doc-blitz/">博客</a>
          </li>
        </ul>
      </div>

      <ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex">
        <li class="nav-item dropdown">
          <a class="nav-item nav-link dropdown-toggle mr-md-2" href="#" id="tk-langs" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            中文
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="tk-langs">
            <a class="dropdown-item active" href="#">中文</a>
            <a class="dropdown-item" href="https://tokio-zh.github.io/" rel="nofollow">官方中文</a>
            <a class="dropdown-item" href="https://tokio.rs" rel="nofollow">English</a>
          </div>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://github.com/tokio-rs/tokio" target="_blank" rel="noopener" aria-label="GitHub">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 499.36" focusable="false"><title>GitHub</title><path d="M256 0C114.64 0 0 114.61 0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34 0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49 0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75 0 0 21.49-6.88 70.4 26.24a242.65 242.65 0 0 1 128.18 0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69 0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41 0 34.22-.31 61.83-.31 70.23 0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37 0 256 0z" fill="currentColor" fill-rule="evenodd"/></svg>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://twitter.com/tokio_rs" target="_blank" rel="noopener" aria-label="Twitter">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 416.32" focusable="false"><title>Twitter</title><path d="M160.83 416.32c193.2 0 298.92-160.22 298.92-298.92 0-4.51 0-9-.2-13.52A214 214 0 0 0 512 49.38a212.93 212.93 0 0 1-60.44 16.6 105.7 105.7 0 0 0 46.3-58.19 209 209 0 0 1-66.79 25.37 105.09 105.09 0 0 0-181.73 71.91 116.12 116.12 0 0 0 2.66 24c-87.28-4.3-164.73-46.3-216.56-109.82A105.48 105.48 0 0 0 68 159.6a106.27 106.27 0 0 1-47.53-13.11v1.43a105.28 105.28 0 0 0 84.21 103.06 105.67 105.67 0 0 1-47.33 1.84 105.06 105.06 0 0 0 98.14 72.94A210.72 210.72 0 0 1 25 370.84a202.17 202.17 0 0 1-25-1.43 298.85 298.85 0 0 0 160.83 46.92" fill="currentColor"/></svg>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link p-2" href="https://gitter.im/tokio-rs/tokio" target="_blank" rel="noopener" aria-label="Gitter">
            <svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" focusable="false"><title>Gitter</title><path fill="currentColor" d="M8.501 4.001H10.5V24H8.501V4.001zm6.999 0V24h-2V4.001h2zM3.5 0h2.001v15H3.5V0zm15 4.001h2V15h-2V4.001z"/></svg>
          </a>
        </li>
      </ul>
    </header>



<div class="container-fluid tk-docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 tk-sidebar">
      <form class="tk-search d-flex align-items-center">
        <span class="algolia-autocomplete algolia-autocomplete-left" style="position: relative; display: inline-block; direction: ltr;">
          <input class="form-control ds-input" id="search-input" placeholder="搜索……" autocomplete="off" spellcheck="false" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-owns="algolia-autocomplete-listbox-0" style="position: relative; vertical-align: top;" dir="auto" type="search">
          <pre aria-hidden="true" style="position: absolute; visibility: hidden; white-space: pre; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 16px; font-style: normal; font-variant: normal; font-weight: 400; word-spacing: 0px; letter-spacing: normal; text-indent: 0px; text-rendering: optimizelegibility; text-transform: none;">w</pre>
          <span class="ds-dropdown-menu ds-with-1" style="position: absolute; top: 100%; left: 0px; z-index: 100; right: auto; display: none;" role="listbox" id="algolia-autocomplete-listbox-0">
            <div class="ds-dataset-1"></div>
          </span>
        </span>
        <button class="btn btn-link tk-search-docs-toggle d-md-none p-0 ml-3" type="button" data-toggle="collapse" data-target="#tk-docs-nav" aria-controls="tk-docs-nav" aria-expanded="false" aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false">
            <title>Menu</title><path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"></path></svg>
        </button>
      </form>

      <nav class="tk-links collapse" id="tk-docs-nav">
          
          
            
              <div class="tk-toc-item">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/overview/">
                  Tokio 是什么？
                </a>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/getting-started/hello-world/">
                  入门
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/hello-world/" class="">Hello World!</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/futures/" class="">Futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/runtime/" class="">Runtime</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/getting-started/echo/" class="">Example: An Echo Server</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/futures/overview/">
                  使用 future
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/overview/" class="">Overview</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/basic/" class="">Implementing futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/getting_asynchronous/" class="">Getting asynchronous</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/combinators/" class="">Combinators</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/streams/" class="">Streams</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/spawning/" class="">Spawning</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/leaf-futures/" class="">Leaf futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/futures/runtime-model/" class="">Runtime model</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/io/overview/">
                  使用 Tokio 的 I/O
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/io/overview/" class="">I/O Overview</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/reading_writing_data/" class="">Reading and Writing Data</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/async_read_write/" class="">Using AsyncRead and AsyncWrite directly</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/impl_async_read_write/" class="">Implementing Async Read/Write</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/filesystem/" class="">Filesystem APIs</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/io/datagrams/" class="">Datagram APIs</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item active">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/going-deeper/futures/">
                  深入
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/futures/" class="">Futures: In Depth</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/tasks/" class="active">Tasks</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/runtime-model/" class="">运行时模型</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/io/" class="">I/O with Tokio</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/chat/" class="">Example: A Chat Server</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/timers/" class="">Timers</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/futures-mechanics/" class="">Essential combinators</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/returning/" class="">Returning futures</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/frames/" class="">Working with framed streams</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/going-deeper/building-runtime/" class="">Building a runtime</a></li>
                
                </ul>
              </div>
            
          
            
              
              <div class="tk-toc-item ">
                <a class="tk-toc-link" href="https://tokio-cn.github.io/docs/internals/intro/">
                  Tokio 内部原理
                </a>
                <ul class="nav tk-sidenav">
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/intro/" class="">Introduction</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/runtime-model/" class="">Runtime model</a></li>
                
                  <li><a href="https://tokio-cn.github.io/docs/internals/net/" class="">Non-blocking I/O</a></li>
                
                </ul>
              </div>
            
          
            
              <div class="tk-toc-item">
                <a class="tk-toc-link" href="https://docs.rs/tokio">
                  API 文档
                </a>
              </div>
            
          
      </nav>
    </div>
    <div class="d-none d-xl-block col-xl-2 tk-toc">
      <div class="section-nav">
        <nav id="TableOfContents">
<ul>
<li><a href="#message-passing">Message Passing</a></li>
<li><a href="#task-notification">Task Notification</a></li>
</ul>
</nav>
      </div>
    </div>
    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 tk-content tk-docs">
      <h1 class="tk-title">Tasks</h1>
      <div class="github-edit">
        <a class="fa fa-github" href="https://github.com/hltj/tokio-website-cn/tree/master/content/docs/going-deeper/tasks.md"> 在 GitHub 上编辑</a>
      </div>
      

<p>Tasks are the application&rsquo;s &ldquo;unit of logic&rdquo;. They are similar to <a href="https://www.golang-book.com/books/intro/10">Go&rsquo;s
goroutine</a> and <a href="http://erlang.org/doc/reference_manual/processes.html">Erlang&rsquo;s process</a>, but asynchronous. In other words, tasks are
asynchronous green threads.</p>

<p>Given that a task runs an asynchronous bit of logic, they are represented by the
<a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>Future</code></a> trait. The task&rsquo;s future implementation completes with a <code>()</code> value
once the task is done processing.</p>

<p>Tasks are passed to <a href="#">executors</a>, which handle scheduling the task. An executor
usually is scheduling many tasks across a single or small set of threads.
<strong>Tasks must not perform computation heavy logic or they will prevent other
tasks from executing</strong>. So don&rsquo;t try to compute the fibonacci sequence as a
task.</p>

<p>Tasks are implemented by either implementing the <a href="https://docs.rs/futures/0.1/futures/future/trait.Future.html"><code>Future</code></a> trait directly or by
building up a future using the various combinator functions available in the
<a href="https://docs.rs/futures/0.1/futures"><code>futures</code></a> and <a href="https://docs.rs/tokio/0.1/tokio"><code>tokio</code></a> crates.</p>

<p>Here is an example that fetches the value from a URI using an HTTP get and
caches the result.</p>

<p>The logic is as follows:</p>

<ol>
<li>Check the cache to see if there is an entry for the URI.</li>
<li>If there is no entry, perform the HTTP get.</li>
<li>Store the response in the cache.</li>
<li>Return the response.</li>
</ol>

<p>The entire sequence of events is also wrapped with a timeout in order to prevent
unbounded execution time.</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# extern crate futures;
# use futures::prelude::*;
# use futures::future::{self, Either, empty};
# use std::time::Duration;
# fn docx() {
#
# pub struct Timeout;
# impl Timeout {
#     pub fn new&lt;T&gt;(_: T, _: Duration) -&gt; impl Future&lt;Item = (), Error = ()&gt; {
#         empty()
#     }
# }
# pub struct MyExecutor;
# impl MyExecutor {
#     fn spawn&lt;T&gt;(&amp;self, _: T) {
#         unimplemented!();
#     }
# }
# pub struct Error;

// The functions here all return `impl Future&lt;...&gt;`. This is one
// of a number of ways to return futures. For more details on
// returning futures, see the &quot;Returning futures&quot; section in
// &quot;Going deeper: Futures&quot;.

/// Get a URI from some remote cache.
fn cache_get(uri: &amp;str)
    -&gt; impl Future&lt;Item = Option&lt;String&gt;, Error = Error&gt;
# { empty() } /*
{ ... }
# */

fn cache_put(uri: &amp;str, val: String)
    -&gt; impl Future&lt;Item = (), Error = Error&gt;
# { empty() } /*
{ ... }
# */

/// Do a full HTTP get to a remote URL
fn http_get(uri: &amp;str)
    -&gt; impl Future&lt;Item = String, Error = Error&gt;
# { empty() } /*
{ ... }
# */
#
# let my_executor = MyExecutor;

fn fetch_and_cache(url: &amp;str)
    -&gt; impl Future&lt;Item = String, Error = Error&gt;
{
    // The URL has to be converted to a string so that it can be
    // moved into the closure. Given futures are asynchronous,
    // the stack is not around anymore by the time the closure is called.
    let url = url.to_string();

    let response = http_get(&amp;url)
        .and_then(move |response| {
            cache_put(&amp;url, response.clone())
                .map(|_| response)
        });

    Box::new(response)
}

let url = &quot;https://example.com&quot;;

let response = cache_get(url)
  .and_then(|resp| {
      // `Either` is a utility provided by the `futures` crate
      // that enables returning different futures from a single
      // closure without boxing.
      match resp {
          Some(resp) =&gt; Either::A(future::ok(resp)),
          None =&gt; {
              Either::B(fetch_and_cache(url))
          }
      }
  });

// Only let the task run for up to 20 seconds.
//
// This uses a fictional timer API. Use the `tokio-timer` crate for
// all your actual timer needs.
let task = Timeout::new(response, Duration::from_secs(20));

my_executor.spawn(task);
# }
# fn main() {}
</code></pre>

<p>Because the steps are all necessary for the task to complete, it makes sense to
group them all within the same task.</p>

<p>However, if instead of updating the cache on a cache-miss, we wanted to update
the cache value on an interval, then it would make sense to split that into
multiple tasks as the steps are no longer directly related.</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# extern crate futures;
# use futures::prelude::*;
# use futures::future::{self, Either, empty};
# use std::time::Duration;
# fn docx() {
#
# pub struct Timeout;
# impl Timeout {
#     pub fn new&lt;T&gt;(_: T, _: Duration) -&gt; impl Future&lt;Item = (), Error = ()&gt; {
#         empty()
#     }
# }
# pub struct Interval;
# impl Interval {
#     pub fn new(_: Duration) -&gt; Box&lt;Stream&lt;Item = (), Error = Error&gt;&gt; {
#         unimplemented!();
#     }
# }
# pub struct MyExecutor;
# impl MyExecutor {
#     fn spawn&lt;T&gt;(&amp;self, _: T) {
#         unimplemented!();
#     }
# }
# pub struct Error;
#
# fn cache_get(uri: &amp;str)
#     -&gt; impl Future&lt;Item = Option&lt;String&gt;, Error = Error&gt;
# { empty() }
# fn cache_put(uri: &amp;str, val: String)
#     -&gt; impl Future&lt;Item = (), Error = Error&gt;
# { empty() }
# fn http_get(uri: &amp;str)
#     -&gt; impl Future&lt;Item = String, Error = Error&gt;
# { empty() }
# fn fetch_and_cache(url: &amp;str)
#     -&gt; impl Future&lt;Item = String, Error = Error&gt;
# { empty() }
# let my_executor = MyExecutor;

let url = &quot;https://example.com&quot;;

// An Interval is a stream that yields `()` on a fixed interval.
let update_cache = Interval::new(Duration::from_secs(60))
    // On each tick of the interval, update the cache. This is done
    // by using the same function from the previous snippet.
    .for_each(|_| {
        fetch_and_cache(url)
            .map(|resp| println!(&quot;updated cache with {}&quot;, resp))
    });

// Spawn the cache update task so that it runs in the background
my_executor.spawn(update_cache);

// Now, only get from the cache.
// (NB: see next section about ensuring the cache is up to date.)
let response = cache_get(url);
let task = Timeout::new(response, Duration::from_secs(20));

my_executor.spawn(task);
# }
# fn main() {}
</code></pre>

<h1 id="message-passing">Message Passing</h1>

<p>Just as with Go and Erlang, tasks can communicate using message passing. In
fact, it will be very common to use message passing to coordinate multiple
tasks. This allows independent tasks to still interact.</p>

<p>The <a href="https://docs.rs/futures/0.1/futures"><code>futures</code></a> crate provides a <a href="https://docs.rs/futures/0.1/futures/sync/index.html"><code>sync</code></a> module which contains some channel
types that are ideal for message passing across tasks.</p>

<ul>
<li><a href="https://docs.rs/futures/0.1/futures/sync/oneshot/index.html"><code>oneshot</code></a> is a channel for sending exactly one value.</li>
<li><a href="https://docs.rs/futures/0.1/futures/sync/mpsc/index.html"><code>mpsc</code></a> is a channel for sending many (zero or more) values.</li>
</ul>

<p>The previous example isn&rsquo;t exactly correct. Given that tasks are executed
concurrently, there is no guarantee that the cache updating task will have
written the first value to the cache by the time the other task tries to read
from the cache.</p>

<p>This is a perfect situation to use message passing. The cache updating task can
send a message notifying the other task that it has primed the cache with an
initial value.</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# extern crate futures;
# use futures::prelude::*;
# use futures::future::{self, Either, empty};
# use futures::sync::oneshot;
# use std::time::Duration;
# fn docx() {
#
# pub struct Timeout;
# impl Timeout {
#     pub fn new&lt;T&gt;(_: T, _: Duration) -&gt; impl Future&lt;Item = (), Error = ()&gt; {
#         empty()
#     }
# }
# pub struct Interval;
# impl Interval {
#     pub fn new(_: Duration) -&gt; Box&lt;Stream&lt;Item = (), Error = Error&gt;&gt; {
#         unimplemented!();
#     }
# }
# pub struct MyExecutor;
# impl MyExecutor {
#     fn spawn&lt;T&gt;(&amp;self, _: T) {
#         unimplemented!();
#     }
# }
# pub struct Error;
#
# fn cache_get(uri: &amp;str)
#     -&gt; impl Future&lt;Item = Option&lt;String&gt;, Error = Error&gt;
# { empty() }
# fn cache_put(uri: &amp;str, val: String)
#     -&gt; impl Future&lt;Item = (), Error = Error&gt;
# { empty() }
# fn http_get(uri: &amp;str)
#     -&gt; impl Future&lt;Item = String, Error = Error&gt;
# { empty() }
# fn fetch_and_cache(url: &amp;str)
#     -&gt; impl Future&lt;Item = String, Error = Error&gt;
# { empty() }
# let my_executor = MyExecutor;

let url = &quot;https://example.com&quot;;

let (primed_tx, primed_rx) = oneshot::channel();

let update_cache = fetch_and_cache(url)
    // Now, notify the other task that the cache is primed
    .then(|_| primed_tx.send(()))
    // Then we can start refreshing the cache on an interval
    .then(|_| {
        Interval::new(Duration::from_secs(60))
            .for_each(|_| {
                fetch_and_cache(url)
                    .map(|resp| println!(&quot;updated cache with {}&quot;, resp))
            })
    });

// Spawn the cache update task so that it runs in the background
my_executor.spawn(update_cache);

// First, wait for the cache to primed
let response = primed_rx
    .then(|_| cache_get(url));

let task = Timeout::new(response, Duration::from_secs(20));

my_executor.spawn(task);
# }
# fn main() {}
</code></pre>

<h1 id="task-notification">Task Notification</h1>

<p>An application built with Tokio is structured as a set of concurrently running
tasks. Here is the basic structure of a server:</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# extern crate futures;
# extern crate tokio;
#
# use tokio::io;
# use tokio::net::{TcpListener, TcpStream};
# use tokio::prelude::*;
# use futures::future::empty;
#
# pub fn process(socket: TcpStream) -&gt; impl Future&lt;Item = (), Error = ()&gt; + Send {
#   empty()
# }
#
# fn docx() {
#     let addr = &quot;127.0.0.1:6142&quot;.parse().unwrap();
#     let listener = TcpListener::bind(&amp;addr).unwrap();
let server = listener.incoming().for_each(|socket| {
    // Spawn a task to process the connection
    tokio::spawn(process(socket));

    Ok(())
})
.map_err(|_| ()); // Just drop the error

tokio::run(server);
# }
# pub fn main() {}
</code></pre>

<p>In this case, we spawn a task for each inbound server socket. However, it is
also possible to implement a server future that processes all inbound
connections on the same socket:</p>

<pre><code class="language-rust"># #![deny(deprecated)]
# extern crate futures;
# extern crate tokio;
# use futures::prelude::*;
# use tokio::net::*;
# use std::io;
# use futures::future::empty;

pub struct Server {
    listener: TcpListener,
    connections: Vec&lt;Box&lt;Future&lt;Item = (), Error = io::Error&gt; + Send&gt;&gt;,
}
# pub fn process(socket: TcpStream) -&gt; impl Future&lt;Item = (), Error = io::Error&gt; + Send {
#   empty()
# }

impl Future for Server {
    type Item = ();
    type Error = io::Error;

    fn poll(&amp;mut self) -&gt; Result&lt;Async&lt;()&gt;, io::Error&gt; {
        // First, accept all new connections
        loop {
            match self.listener.poll_accept()? {
                Async::Ready((socket, _)) =&gt; {
                    let connection = process(socket);
                    self.connections.push(Box::new(connection));
                }
                Async::NotReady =&gt; break,
            }
        }

        // Now, poll all connection futures.
        let len = self.connections.len();

        for i in (0..len).rev() {
            match self.connections[i].poll()? {
                Async::Ready(_) =&gt; {
                    self.connections.remove(i);
                }
                Async::NotReady =&gt; {}
            }
        }

        // `NotReady` is returned here because the future never actually
        // completes. The server runs until it is dropped.
        Ok(Async::NotReady)
    }
}
# pub fn main() {}
</code></pre>

<p>These two strategies are functionally equivalent, but have significantly
different runtime characteristics.</p>

<p>Notifications happens at the task level. The task does not know which
sub future triggered the notification. So, whenever the task is polled, it has
to try polling all sub futures.</p>


<figure>
    
        <img src="https://tokio-cn.github.io/img/diagrams/task-layout.png" alt="Layout of a task" />
    
    
    <figcaption>
        <p>
        Layout of a task
        
            
        
        </p> 
    </figcaption>
    
</figure>


<p>In this task, there are three sub futures that can get polled. If a resource
contained by one of the sub futures transitions to &ldquo;ready&rdquo;, the task itself gets
notified and it will try to poll all three of its sub futures. One of them will
advance, which in turn advances the internal state of the task.</p>

<p>The key is to try to keep tasks small, doing as little as possible per task.
This is why servers spawn new tasks for each connection instead of processing
the connections in the same task as the listener.</p>

<p>Ok, there actually is a way for the task to know which sub future triggered the
notification using <a href="https://docs.rs/futures/0.1/futures/stream/futures_unordered/struct.FuturesUnordered.html"><code>FuturesUnordered</code></a>, but usually the right thing to do is to
spawn a new task.</p>

      
      
        <div class="tk-next">
          <b>下一篇</b>：<a href ="/docs/going-deeper/runtime-model/">运行时模型</a>
        </div>
      
    </main>
  </div>
</div>

    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js" integrity="sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8" crossorigin="anonymous"></script>
    <script src="https://tokio-cn.github.io/js/bootstrap.min.js"></script>
    <script src="https://tokio-cn.github.io/js/highlight.js"></script>
    <script>
      $(function () {
        $("pre code").each(function(i, block) {
          
          if (block.className.indexOf('language-rust') >= 0) {
            var new_content = '';
            var lines = block.textContent.split('\n');
            for (var i = 0; i < lines.length; i++) {
              if (lines[i].indexOf('# ') == 0 || lines[i] == '#') {
                continue
              }
              new_content += lines[i].trimRight() + '\n';
            }
            block.textContent = new_content.replace(/\n\n\n/g, "\n\n").trimRight();
          }
          hljs.highlightBlock(block);
        });
      });
    </script>
    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
    <script type="text/javascript"> docsearch({
    apiKey: 'd7b5b785798fe748621bcaa8301a2201',
    indexName: 'tokio',
    inputSelector: '#search-input',
    debug: false 
    });
    </script>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-122396021-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

