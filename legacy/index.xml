<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Legacies on Tokio</title>
    <link>https://tokio-cn.github.io/legacy/index.xml</link>
    <description>Recent content in Legacies on Tokio</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://tokio-cn.github.io/legacy/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Architecture overview</title>
      <link>https://tokio-cn.github.io/legacy/going-deeper-tokio/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/going-deeper-tokio/architecture/</guid>
      <description>

&lt;p&gt;Most networking applications are structured in a layered fashion.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Byte streams&lt;/strong&gt; are at the lowest layer. They are usually provided by TCP or
UDP sockets. At this layer, operations are made against byte arrays and
usually done with buffers. Besides directly manipulating the socket, this is
also where functionality like
&lt;a href=&#34;https://en.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;TLS&lt;/a&gt; resides.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Framing&lt;/strong&gt; is taking a raw stream of bytes and breaking it up into meaningful
units. For example, HTTP naturally has frames consisting of request headers,
response headers, or body chunks. A line-based protocol consists of &lt;code&gt;String&lt;/code&gt;
frames that are delineated by new line tokens. At this point, instead of
dealing with a stream of raw bytes, we are dealing with a stream of frame
values. In Tokio, we sometimes refer to a full duplex stream of frames as a
&lt;em&gt;transport&lt;/em&gt;, which implements both the &lt;code&gt;Stream&lt;/code&gt; and &lt;code&gt;Sink&lt;/code&gt; traits.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;strong&gt;request / response exchange&lt;/strong&gt; generally is where application logic starts
appearing. For a client, at this layer, a request is issued and a response for
the request is returned. When the request is issued, it is turned into one or
more frames and written to a transport. Then, at some point in the future, a
response to the request will be read from the transport, and matched with the
original request.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At the &lt;strong&gt;application&lt;/strong&gt; layer, the details of how requests and responses are
mapped onto a transport don&amp;rsquo;t matter. A single application may be receiving
and issuing requests for many different protocols. An HTTP server application
will be receiving HTTP requests, and then in turn, issuing database requests
or other HTTP requests.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of these layers tend to be implemented in different libraries, and the end
application will pull in the protocol implementations and just interact with
them at the request / response exchange layer.&lt;/p&gt;

&lt;p&gt;Tokio&amp;rsquo;s abstractions map onto these different layers.&lt;/p&gt;

&lt;h2 id=&#34;byte-streams&#34;&gt;&lt;a href=&#34;#byte-streams&#34;&gt;Byte streams&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/tokio-rs/tokio-core&#34;&gt;tokio-core&lt;/a&gt; provides the lowest level
building blocks for writing asynchronous I/O code: an
&lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/reactor/&#34;&gt;event loop&lt;/a&gt; and the
&lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/core/#concrete-io&#34;&gt;concrete I/O types&lt;/a&gt;, such as TCP and
UDP sockets.  These primitives work on the byte level much like the &lt;code&gt;std::io&lt;/code&gt;
types, except the Tokio types are non-blocking. Other sections describe both
&lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/core/&#34;&gt;high-level&lt;/a&gt; and
&lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-tokio/core-low-level/&#34;&gt;low-level&lt;/a&gt; APIs for working with byte
streams.&lt;/p&gt;

&lt;h2 id=&#34;framing&#34;&gt;&lt;a href=&#34;#framing&#34;&gt;Framing&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Framing is done with Tokio by first defining a frame type, usually an
&lt;code&gt;enum&lt;/code&gt;, then implementing a transport as a &lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/streams-and-sinks/&#34;&gt;&lt;code&gt;Stream + Sink&lt;/code&gt;&lt;/a&gt; that works with that frame type. The
transport handles encoding and decoding the frame values to the raw
stream of bytes. This can either be done
&lt;a href=&#34;https://tokio-cn.github.io/docs/going-deeper/transports/#implementing&#34;&gt;manually&lt;/a&gt; or using a
helper like &lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/core/#io-codecs&#34;&gt;&lt;code&gt;framed&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Later sections cover &lt;a href=&#34;../transports&#34;&gt;working with transports&lt;/a&gt; and
&lt;a href=&#34;../handshake&#34;&gt;handshakes in particular&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;request-response&#34;&gt;&lt;a href=&#34;#request-response&#34;&gt;Request / Response&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The request / response exchange layer is handled by Tokio&amp;rsquo;s &lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt;
trait. The &lt;code&gt;Service&lt;/code&gt; trait is a simplified interface making it easy to write
network applications in a modular and reusable way, decoupled from the
underlying protocol. It is one of Tokio&amp;rsquo;s fundamental abstractions. It is a
similar abstraction to Finagle&amp;rsquo;s &lt;code&gt;Service&lt;/code&gt;, Ruby&amp;rsquo;s Rack, or Java&amp;rsquo;s servlet;
however, Tokio&amp;rsquo;s &lt;code&gt;Service&lt;/code&gt; trait is abstract over the underlying protocol.&lt;/p&gt;

&lt;p&gt;There are generally two ways to map request / responses to a stream of
frames: pipelined or &lt;a href=&#34;https://tokio-cn.github.io/docs/going-deeper/multiplex&#34;&gt;multiplexing&lt;/a&gt;.
&lt;a href=&#34;https://github.com/tokio-rs/tokio-proto&#34;&gt;tokio-proto&lt;/a&gt;&amp;rsquo;s goal is to take a transport and handle the required
logic to map that to an implementation of &lt;code&gt;Service&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A big advantage of having a standardized &lt;code&gt;Service&lt;/code&gt; interface is that it makes
it possible to write reusable middleware components that add useful
functionality.&lt;/p&gt;

&lt;h2 id=&#34;application&#34;&gt;&lt;a href=&#34;#application&#34;&gt;Application&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Generally, all the previously listed layers will be implemented in libraries.
For example, an HTTP server implementation would implement an HTTP transport,
then use &lt;a href=&#34;https://github.com/tokio-rs/tokio-proto&#34;&gt;tokio-proto&lt;/a&gt; to map that to a &lt;code&gt;Service&lt;/code&gt;. The &lt;code&gt;Service&lt;/code&gt; is what
the HTTP library would expose.&lt;/p&gt;

&lt;p&gt;An application would depend on many different libraries, providing various
protocol implementations exposed as services, and using the &lt;a href=&#34;https://github.com/alexcrichton/futures-rs&#34;&gt;futures&lt;/a&gt;
library to hook everything together.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Connection handshakes</title>
      <link>https://tokio-cn.github.io/legacy/going-deeper-tokio/handshake/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/going-deeper-tokio/handshake/</guid>
      <description>

&lt;p&gt;Some protocols require some setup before they can start accepting requests. For
example, PostgreSQL requires a &lt;a href=&#34;https://www.postgresql.org/docs/9.3/static/protocol-flow.html#AEN99290&#34;&gt;start-up
message&lt;/a&gt;,
Transport Layer Security requires a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_handshake&#34;&gt;handshake&lt;/a&gt;,
and so does &lt;a href=&#34;http://httpwg.org/specs/rfc7540.html#starting&#34;&gt;HTTP/2.0&lt;/a&gt;. This
section will show how to model that using Tokio.&lt;/p&gt;

&lt;p&gt;This guide will build off of the &lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/simple-server/&#34;&gt;simple line-based
protocol&lt;/a&gt; we saw earlier. Let&amp;rsquo;s look at the
protocol specification again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_io;
# extern crate tokio_proto;
# extern crate bytes;

use tokio_io::{AsyncRead, AsyncWrite};
use tokio_io::codec::{Framed, Encoder, Decoder};
use tokio_proto::pipeline::ServerProto;
use std::io;

struct LineProto;
#
# use bytes::BytesMut;
# struct LineCodec;
# impl Encoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn encode(&amp;amp;mut self, msg: String, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
#       buf.extend(msg.as_bytes());
#       buf.extend(b&amp;quot;\n&amp;quot;);
#       Ok(())
#   }
# }
# impl Decoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt; {
#       if let Some(i) = buf.iter().position(|&amp;amp;b| b == b&#39;\n&#39;) {
#           // remove the serialized frame from the buffer.
#           let line = buf.split_to(i);
#
#           // Also remove the &#39;\n&#39;
#           buf.split_to(1);
#
#           // Turn this data into a UTF string and return it in a Frame.
#           match std::str::from_utf8(&amp;amp;line) {
#               Ok(s) =&amp;gt; Ok(Some(s.to_string())),
#               Err(_) =&amp;gt; Err(io::Error::new(io::ErrorKind::Other,
#                                            &amp;quot;invalid UTF-8&amp;quot;)),
#           }
#       } else {
#           Ok(None)
#       }
#   }
# }
#

impl&amp;lt;T: AsyncRead + AsyncWrite + &#39;static&amp;gt; ServerProto&amp;lt;T&amp;gt; for LineProto
{
    type Request = String;
    type Response = String;

    // `Framed&amp;lt;T, LineCodec&amp;gt;` is the return value of
    // `io.framed(LineCodec)`
    type Transport = Framed&amp;lt;T, LineCodec&amp;gt;;
    type BindTransport = Result&amp;lt;Self::Transport, io::Error&amp;gt;;

    fn bind_transport(&amp;amp;self, io: T) -&amp;gt; Self::BindTransport {
        Ok(io.framed(LineCodec))
    }
}
# pub fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://tokio-rs.github.io/tokio-proto/tokio_proto/pipeline/trait.ServerProto.html#associatedtype.BindTransport&#34;&gt;&lt;code&gt;BindTransport&lt;/code&gt;&lt;/a&gt; associated type, returned from the &lt;code&gt;bind_transport&lt;/code&gt;
function is an &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.IntoFuture.html&#34;&gt;&lt;code&gt;IntoFuture&lt;/code&gt;&lt;/a&gt;. This means that all connection setup work
can be done before realizing the &lt;code&gt;BindTransport&lt;/code&gt; future. So far, none of our
protocols needed any setup, so we just used &lt;code&gt;Result&lt;/code&gt;. But now, we&amp;rsquo;re going
to change that.&lt;/p&gt;

&lt;h2 id=&#34;implementing-handshake&#34;&gt;&lt;a href=&#34;#implementing-handshake&#34;&gt;Implementing the handshake&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re going to modify our line-based protocol. When a client connects to a
server, it has to send the following line: &lt;code&gt;You ready?&lt;/code&gt;. Once the server is
ready to accept requests, it responds with: &lt;code&gt;Bring it!&lt;/code&gt;. If the server wants to
reject the client for some reason, it responds with: &lt;code&gt;No! Go away!&lt;/code&gt;. The client
is then expected to close the socket.&lt;/p&gt;

&lt;p&gt;The server implementation of the handshake looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_io;
# extern crate tokio_proto;
# extern crate bytes;
# extern crate futures;
#
# use tokio_io::{AsyncRead, AsyncWrite};
# use tokio_io::codec::{Framed, Encoder, Decoder};
# use tokio_proto::pipeline::ServerProto;
# use futures::{future, Stream, Future, Sink};
# use std::io;
#
# struct LineProto;
#
# use bytes::BytesMut;
# struct LineCodec;
# impl Encoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn encode(&amp;amp;mut self, msg: String, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
#       buf.extend(msg.as_bytes());
#       buf.extend(b&amp;quot;\n&amp;quot;);
#       Ok(())
#   }
# }
# impl Decoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt; {
#       if let Some(i) = buf.iter().position(|&amp;amp;b| b == b&#39;\n&#39;) {
#           // remove the serialized frame from the buffer.
#           let line = buf.split_to(i);
#
#           // Also remove the &#39;\n&#39;
#           buf.split_to(1);
#
#           // Turn this data into a UTF string and return it in a Frame.
#           match std::str::from_utf8(&amp;amp;line) {
#               Ok(s) =&amp;gt; Ok(Some(s.to_string())),
#               Err(_) =&amp;gt; Err(io::Error::new(io::ErrorKind::Other,
#                                            &amp;quot;invalid UTF-8&amp;quot;)),
#           }
#       } else {
#           Ok(None)
#       }
#   }
# }
#
# impl&amp;lt;T: AsyncRead + AsyncWrite + &#39;static&amp;gt; ServerProto&amp;lt;T&amp;gt; for LineProto {
#     type Request = String;
#     type Response = String;
#
#     // `Framed&amp;lt;T, LineCodec&amp;gt;` is the return value of
#     // `io.framed(LineCodec)`
#     type Transport = Framed&amp;lt;T, LineCodec&amp;gt;;
#     type BindTransport = Box&amp;lt;Future&amp;lt;Item = Self::Transport, Error = io::Error&amp;gt;&amp;gt;;
#
#     fn bind_transport(&amp;amp;self, io: T) -&amp;gt; Self::BindTransport {
#         // Construct the line-based transport
#         let transport = io.framed(LineCodec);
#
#         // The handshake requires that the client sends `You ready?`, so wait to
#         // receive that line. If anything else is sent, error out the connection
#         Box::new(
transport.into_future()
    // If the transport errors out, we don&#39;t care about the transport
    // anymore, so just keep the error
    .map_err(|(e, _)| e)
    .and_then(|(line, transport)| {
        // A line has been received, check to see if
        // it is the handshake
        match line {
            Some(ref msg) if msg == &amp;quot;You ready?&amp;quot; =&amp;gt; {
                println!(&amp;quot;SERVER: received client handshake&amp;quot;);
                // Send back the acknowledgement
                Box::new(transport.send(&amp;quot;Bring it!&amp;quot;.to_string()))
#                     as Self::BindTransport
            }
            _ =&amp;gt; {
                // The client sent an unexpected handshake, error out
                // the connection
                println!(&amp;quot;SERVER: client handshake INVALID&amp;quot;);
                let err = io::Error::new(io::ErrorKind::Other,
                                         &amp;quot;invalid handshake&amp;quot;);
                Box::new(future::err(err))
# as Self::BindTransport
            }
        }
    })
# )
#     }
# }
# pub fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The transport returned by &lt;code&gt;AsyncRead::framed&lt;/code&gt; is a value implementing &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; +
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html&#34;&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/a&gt; over the frame type. In our case, the frame type is &lt;code&gt;String&lt;/code&gt;, so we can
use the transport directly in order to implement our handshake logic.&lt;/p&gt;

&lt;p&gt;The above snippet returns a future that completes with the transport when the
handshake has been completed.&lt;/p&gt;

&lt;h2 id=&#34;updating-protocol&#34;&gt;&lt;a href=&#34;#updating-protocol&#34;&gt;Updating the protocol&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The next step is to update the &lt;code&gt;bind_transport&lt;/code&gt; function in our protocol
specification. Instead of returning the transport directly, we will perform the
handshake shown above. Here&amp;rsquo;s the full code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_io;
# extern crate tokio_proto;
# extern crate bytes;
# extern crate futures;
#
# use tokio_io::{AsyncRead, AsyncWrite};
# use tokio_io::codec::{Framed, Encoder, Decoder};
# use tokio_proto::pipeline::ServerProto;
# use futures::{future, Stream, Future, Sink};
# use std::io;
#
# struct LineProto;
#
# use bytes::BytesMut;
# struct LineCodec;
# impl Encoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn encode(&amp;amp;mut self, msg: String, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
#       buf.extend(msg.as_bytes());
#       buf.extend(b&amp;quot;\n&amp;quot;);
#       Ok(())
#   }
# }
# impl Decoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt; {
#       if let Some(i) = buf.iter().position(|&amp;amp;b| b == b&#39;\n&#39;) {
#           // remove the serialized frame from the buffer.
#           let line = buf.split_to(i);
#
#           // Also remove the &#39;\n&#39;
#           buf.split_to(1);
#
#           // Turn this data into a UTF string and return it in a Frame.
#           match std::str::from_utf8(&amp;amp;line) {
#               Ok(s) =&amp;gt; Ok(Some(s.to_string())),
#               Err(_) =&amp;gt; Err(io::Error::new(io::ErrorKind::Other,
#                                            &amp;quot;invalid UTF-8&amp;quot;)),
#           }
#       } else {
#           Ok(None)
#       }
#   }
# }
#
impl&amp;lt;T: AsyncRead + AsyncWrite + &#39;static&amp;gt; ServerProto&amp;lt;T&amp;gt; for LineProto
{
    type Request = String;
    type Response = String;

    // `Framed&amp;lt;T, LineCodec&amp;gt;` is the return value of
    // `io.framed(LineCodec)`
    type Transport = Framed&amp;lt;T, LineCodec&amp;gt;;
    type BindTransport = Box&amp;lt;Future&amp;lt;Item = Self::Transport,
                                   Error = io::Error&amp;gt;&amp;gt;;

    fn bind_transport(&amp;amp;self, io: T) -&amp;gt; Self::BindTransport {
        // Construct the line-based transport
        let transport = io.framed(LineCodec);

        // The handshake requires that the client sends `You ready?`,
        // so wait to receive that line. If anything else is sent,
        // error out the connection
        Box::new(transport.into_future()
            // If the transport errors out, we don&#39;t care about
            // the transport anymore, so just keep the error
            .map_err(|(e, _)| e)
            .and_then(|(line, transport)| {
                // A line has been received, check to see if it
                // is the handshake
                match line {
                    Some(ref msg) if msg == &amp;quot;You ready?&amp;quot; =&amp;gt; {
                        println!(&amp;quot;SERVER: received client handshake&amp;quot;);
                        // Send back the acknowledgement
                        let ret = transport.send(&amp;quot;Bring it!&amp;quot;.into());
                        Box::new(ret) as Self::BindTransport
                    }
                    _ =&amp;gt; {
                        // The client sent an unexpected handshake,
                        // error out the connection
                        println!(&amp;quot;SERVER: client handshake INVALID&amp;quot;);
                        let err = io::Error::new(io::ErrorKind::Other,
                                                 &amp;quot;invalid handshake&amp;quot;);
                        let ret = future::err(err);
                        Box::new(ret) as Self::BindTransport
                    }
                }
            }))
    }
}
# pub fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, if we use &lt;code&gt;TcpServer&lt;/code&gt; to start a server with our &lt;code&gt;ServerLineProto&lt;/code&gt;, the
handshake will be performed before requests start being processed.&lt;/p&gt;

&lt;p&gt;The full working code for both the client and server can be found
&lt;a href=&#34;https://github.com/tokio-rs/tokio-line/blob/master/simple/examples/handshake.rs&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Essential combinators</title>
      <link>https://tokio-cn.github.io/legacy/going-deeper-futures/futures-mechanics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/going-deeper-futures/futures-mechanics/</guid>
      <description>

&lt;p&gt;We saw a few of the most important combinators in the
&lt;a href=&#34;../../getting-started/futures&#34;&gt;futures&lt;/a&gt; and
&lt;a href=&#34;../../getting-started/streams-and-sinks&#34;&gt;streams&lt;/a&gt; overviews. Here we&amp;rsquo;ll take a
look at a few more. It&amp;rsquo;s also worth spending some time with the trait
documentation to familiarize yourself with the full range of combinators
available (&lt;a href=&#34;https://tokio-cn.github.io/img/diagrams/cheatsheet-for-futures.html&#34;&gt;cheatsheet&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;concrete&#34;&gt;&lt;a href=&#34;#concrete&#34;&gt;Some concrete futures and streams&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Any value can be turned into an immediately complete future. There are a few
functions in the &lt;code&gt;future&lt;/code&gt; module for creating such a future:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/fn.ok.html&#34;&gt;&lt;code&gt;ok&lt;/code&gt;&lt;/a&gt;, which is analogous to &lt;code&gt;Result::Ok&lt;/code&gt;: it treats the value you give it as an immediately successful future.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/fn.err.html&#34;&gt;&lt;code&gt;err&lt;/code&gt;&lt;/a&gt;, which is analogous to &lt;code&gt;Result::Err&lt;/code&gt;: it treats the value you give it as an immediately failed future.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/fn.result.html&#34;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt;, which lifts a result to an immediately-complete future.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For streams, there are a few equivalents of an &amp;ldquo;immediately ready&amp;rdquo; stream:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/fn.iter.html&#34;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt;, which creates a stream that yields the same items as the underlying
iterator. The iterator produces &lt;code&gt;Result&lt;/code&gt; values, and the first error terminates
the stream with that error.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/fn.once.html&#34;&gt;&lt;code&gt;once&lt;/code&gt;&lt;/a&gt;, which creates a single-element stream from a &lt;code&gt;Result&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition to these constructors, there&amp;rsquo;s also a function, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/fn.lazy.html&#34;&gt;&lt;code&gt;lazy&lt;/code&gt;&lt;/a&gt;, which
allows you to construct a future given a &lt;em&gt;closure&lt;/em&gt; that will produce that future
later, on demand.&lt;/p&gt;

&lt;h3 id=&#34;intofuture&#34;&gt;&lt;a href=&#34;#intofuture&#34;&gt;IntoFuture&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;A crucial API to know about is the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.IntoFuture.html&#34;&gt;&lt;code&gt;IntoFuture&lt;/code&gt;&lt;/a&gt; trait, which is a trait for
values that can be converted into futures. Most APIs that you think of as taking
futures actually work with this trait instead. The key reason: the trait is
implemented for &lt;code&gt;Result&lt;/code&gt;, allowing you to return &lt;code&gt;Result&lt;/code&gt; values in many places
that futures are expected.&lt;/p&gt;

&lt;h3 id=&#34;adapters&#34;&gt;&lt;a href=&#34;#adapters&#34;&gt;Adapters&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Like &lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Future&lt;/code&gt;, &lt;code&gt;Stream&lt;/code&gt; and &lt;code&gt;Sink&lt;/code&gt; traits all come equipped
with a broad range of &amp;ldquo;adapter&amp;rdquo; methods. These methods all consume the receiving
object and return a new, wrapped one. For futures, you can use adapters to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Change the type of a future (&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.map_err&#34;&gt;&lt;code&gt;map_err&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Run another future after one has completed (&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.then&#34;&gt;&lt;code&gt;then&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.or_else&#34;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Figure out which of two futures resolves first (&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.select&#34;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Wait for two futures to both complete (&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.join&#34;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Convert to a trait object (&lt;a href=&#34;https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new&#34;&gt;&lt;code&gt;Box::new&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Convert unwinding into errors (&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.catch_unwind&#34;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For streams, there are a large set of adapters, including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Many in common with &lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, like &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.fold&#34;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.collect&#34;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.filter&#34;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.zip&#34;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.take&#34;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.skip&#34;&gt;&lt;code&gt;skip&lt;/code&gt;&lt;/a&gt; and so on. Note that &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.fold&#34;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.collect&#34;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; produce &lt;em&gt;futures&lt;/em&gt;, and hence their result is computed
asynchronously.&lt;/li&gt;
&lt;li&gt;Adapters for sequencing with futures (&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.then&#34;&gt;&lt;code&gt;then&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.or_else&#34;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Additional adapters for combining streams (&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.merge&#34;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.select&#34;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;Sink&lt;/code&gt; trait currently has fewer adapters; the most important ones were
covered in &lt;a href=&#34;../../getting-started/streams-and-sinks&#34;&gt;the introduction&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, an object that is both a stream and a sink can be broken into separate
stream and sink objects using the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.split&#34;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; adapter.&lt;/p&gt;

&lt;p&gt;All adapters are zero-cost, meaning that no memory is allocated internally and
the implementation will optimize to what you would have otherwise written by
hand.&lt;/p&gt;

&lt;h3 id=&#34;error-handling&#34;&gt;&lt;a href=&#34;#error-handling&#34;&gt;Error handling&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Futures, streams and sinks all treat error handling as a core concern: they are
all equipped with an associated error type, and the various adapter methods
interpret errors in sensible ways. For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The sequencing combinators &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.then&#34;&gt;&lt;code&gt;then&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.or_else&#34;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, and
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.map_err&#34;&gt;&lt;code&gt;map_err&lt;/code&gt;&lt;/a&gt; all chain errors similarly to the &lt;code&gt;Result&lt;/code&gt; type in the standard
library. So, for example, if you chain futures using &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt; and the
first future fails with an error, the chained future is never run.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combinators like &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.select&#34;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.join&#34;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; also deal with errors. For
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.select&#34;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;, the first future to complete &lt;em&gt;in any way&lt;/em&gt; yields an answer,
propagating the error, but also giving access to the other future should you
want to keep working with it. For &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.join&#34;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt;, if any future produces an error,
the entire join produces that error.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By default, futures don&amp;rsquo;t have any special handling for panics. In most cases,
though, futures are ultimately run as tasks within a thread pool, where you&amp;rsquo;ll
want to catch any panic they produce and propagate that elsewhere. The
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.catch_unwind&#34;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; adapter can be used to reify a panic into a &lt;code&gt;Result&lt;/code&gt; without
taking down the worker thread.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Example: a simple pipelined server using core</title>
      <link>https://tokio-cn.github.io/legacy/getting-started/pipeline-server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/getting-started/pipeline-server/</guid>
      <description>&lt;p&gt;Now that we&amp;rsquo;ve seen the basics of &lt;a href=&#34;../core&#34;&gt;high-level I/O using &lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt;,
let&amp;rsquo;s use it to write a simple pipelined server that uses the &lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt; trait
to host an arbitrary service using a simple line-based protocol (much like we
saw in the &lt;a href=&#34;../simple-server&#34;&gt;initial proto example&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll re-use the codec from the &lt;a href=&#34;../simple-server&#34;&gt;initial server example&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;pub struct LineCodec;

impl Decoder for LineCodec {
    type Item = String;
    ...
}

impl Encoder for LineCodec {
    type Item = String;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ll write a server that can host an arbitrary service over this protocol:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,no_run&#34;&gt;# extern crate tokio_io;
# extern crate tokio_core;
# extern crate tokio_service;
# extern crate futures;
# extern crate bytes;
#
# use std::io;
# use tokio_io::{AsyncRead, AsyncWrite};
# use tokio_io::codec::{Encoder, Decoder};
# use bytes::{BytesMut};
#
# pub struct LineCodec;
#
# impl Encoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn encode(&amp;amp;mut self, msg: String, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
#       buf.extend(msg.as_bytes());
#       buf.extend(b&amp;quot;\n&amp;quot;);
#       Ok(())
#   }
# }
# impl Decoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt; {
#       if let Some(i) = buf.iter().position(|&amp;amp;b| b == b&#39;\n&#39;) {
#           // remove the serialized frame from the buffer.
#           let line = buf.split_to(i);
#
#           // Also remove the &#39;\n&#39;
#           buf.split_to(1);
#
#           // Turn this data into a UTF string and return it in a Frame.
#           match std::str::from_utf8(&amp;amp;line) {
#               Ok(s) =&amp;gt; Ok(Some(s.to_string())),
#               Err(_) =&amp;gt; Err(io::Error::new(io::ErrorKind::Other,
#                                            &amp;quot;invalid UTF-8&amp;quot;)),
#           }
#       } else {
#           Ok(None)
#       }
#   }
# }
#
use tokio_core::reactor::Core;
use tokio_core::net::TcpListener;
use tokio_service::{Service, NewService};
use futures::{future, Future, Stream, Sink};

fn serve&amp;lt;S&amp;gt;(s: S) -&amp;gt; io::Result&amp;lt;()&amp;gt;
    where S: NewService&amp;lt;Request = String,
                        Response = String,
                        Error = io::Error&amp;gt; + &#39;static
{
    let mut core = Core::new()?;
    let handle = core.handle();

    let address = &amp;quot;0.0.0.0:12345&amp;quot;.parse().unwrap();
    let listener = TcpListener::bind(&amp;amp;address, &amp;amp;handle)?;

    let connections = listener.incoming();
    let server = connections.for_each(move |(socket, _peer_addr)| {
        let (writer, reader) = socket.framed(LineCodec).split();
        let service = s.new_service()?;

        let responses = reader.and_then(move |req| service.call(req));
        let server = writer.send_all(responses)
            .then(|_| Ok(()));
        handle.spawn(server);

        Ok(())
    });

    core.run(server)
}
#
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The basic structure of the server should look familiar at this point; we&amp;rsquo;ve seen
it several times now. There are two main points of interest here.&lt;/p&gt;

&lt;p&gt;First, the argument to the &lt;code&gt;serve&lt;/code&gt; function. We use &lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html&#34;&gt;&lt;code&gt;NewService&lt;/code&gt;&lt;/a&gt;, a trait for
service &lt;em&gt;instantiation&lt;/em&gt;. The idea is to create a new service instance for each
connection, which allows the service to track per-connection state. The trait
provides a single function, &lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html#tymethod.new_service&#34;&gt;&lt;code&gt;new_service&lt;/code&gt;&lt;/a&gt;, which does the
instantiation. &lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.NewService.html&#34;&gt;&lt;code&gt;NewService&lt;/code&gt;&lt;/a&gt; is automatically implemented for closures that
produce services.&lt;/p&gt;

&lt;p&gt;More interesting is the body of the server, where we put &lt;code&gt;tokio-core&lt;/code&gt;&amp;rsquo;s
high-level APIs into use. First, we use the &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.framed&#34;&gt;&lt;code&gt;AsyncRead::framed&lt;/code&gt;&lt;/a&gt; method to work with
the socket using our codec; what we get back is a &lt;em&gt;transport&lt;/em&gt;&amp;mdash;an object that
is both a &lt;code&gt;Stream&lt;/code&gt; and a &lt;code&gt;Sink&lt;/code&gt;. The &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.split&#34;&gt;&lt;code&gt;Stream::split&lt;/code&gt;&lt;/a&gt; method then breaks this
object into separate stream and sink objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let (writer, reader) = socket.framed(LineCodec).split();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re ready to instantiate the service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let mut service = s.new_service()?;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have a service instance in hand, we can use it to process incoming
requests. Remember that &lt;code&gt;reader&lt;/code&gt; is a stream of requests; we use
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.and_then&#34;&gt;&lt;code&gt;Stream::and_then&lt;/code&gt;&lt;/a&gt; to sequence the service after it (&lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html#tymethod.call&#34;&gt;&lt;code&gt;Service::call&lt;/code&gt;&lt;/a&gt; returns a future):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let responses = reader.and_then(move |req| service.call(req));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ve produced a stream of responses. We write these back to the socket,
using &lt;code&gt;writer&lt;/code&gt; to encode them into our protocol. We also use &lt;code&gt;then&lt;/code&gt; to throw
away the final result, giving us a &lt;code&gt;server&lt;/code&gt; future that&amp;rsquo;s in the right shape to spawn:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let server = writer.send_all(responses).then(|_| Ok(()));
handle.spawn(server);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it&amp;mdash;we&amp;rsquo;ve built a general-purpose server for a line-based
protocol. By using the built-in framing and &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html#method.send_all&#34;&gt;&lt;code&gt;Sink::send_all&lt;/code&gt;&lt;/a&gt; method, we also
get a pretty efficient server: it will batch up handling multiple requests and
responses if they are available. The key is that &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html#method.send_all&#34;&gt;&lt;code&gt;Sink::send_all&lt;/code&gt;&lt;/a&gt; eager
pulls as many elements from the stream as it can, writing them all into the
sink, flushing only at the end.&lt;/p&gt;

&lt;p&gt;To complete the example, let&amp;rsquo;s build one final echo service and plug them together:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;use futures::{Future, future}

struct EchoService;

impl Service for EchoService {
    type Request = String;
    type Response = String;
    type Error = io::Error;
    type Future = Box&amp;lt;Future&amp;lt;Item = String, Error = io::Error&amp;gt;&amp;gt;;
    fn call(&amp;amp;self, input: String) -&amp;gt; Self::Future {
        Box::new(future::ok(input))
    }
}

fn main() {
    if let Err(e) = serve(|| Ok(EchoService)) {
        println!(&amp;quot;Server failed with {}&amp;quot;, e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Example: a toy HTTP&#43;TLS client using core</title>
      <link>https://tokio-cn.github.io/legacy/getting-started/tls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/getting-started/tls/</guid>
      <description>&lt;p&gt;Much of the functionality throughout the Tokio stack is generic, so as to be as
flexible as possible. A great way to show an example of that is to explore how
we might make a simple HTTP request over HTTPS using TLS. In this example we&amp;rsquo;ll
only use &lt;code&gt;tokio-core&lt;/code&gt; for now rather than &lt;code&gt;tokio-proto&lt;/code&gt;, but the concepts
should translate quite readily.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at what a simple fetch of &lt;code&gt;https://www.rust-lang.org/&lt;/code&gt; might
look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate futures;
extern crate native_tls;
extern crate tokio_core;
extern crate tokio_io;
extern crate tokio_tls;

use std::io;
use std::net::ToSocketAddrs;

use futures::Future;
use native_tls::TlsConnector;
use tokio_core::net::TcpStream;
use tokio_core::reactor::Core;
use tokio_tls::TlsConnectorExt;

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();
    let addr = &amp;quot;www.rust-lang.org:443&amp;quot;.to_socket_addrs().unwrap().next().unwrap();

    let cx = TlsConnector::builder().unwrap().build().unwrap();
    let socket = TcpStream::connect(&amp;amp;addr, &amp;amp;handle);

    let tls_handshake = socket.and_then(|socket| {
        let tls = cx.connect_async(&amp;quot;www.rust-lang.org&amp;quot;, socket);
        tls.map_err(|e| {
            io::Error::new(io::ErrorKind::Other, e)
        })
    });
    let request = tls_handshake.and_then(|socket| {
        tokio_io::io::write_all(socket, &amp;quot;\
            GET / HTTP/1.0\r\n\
            Host: www.rust-lang.org\r\n\
            \r\n\
        &amp;quot;.as_bytes())
    });
    let response = request.and_then(|(socket, _request)| {
        tokio_io::io::read_to_end(socket, Vec::new())
    });

    let (_socket, data) = core.run(response).unwrap();
    println!(&amp;quot;{}&amp;quot;, String::from_utf8_lossy(&amp;amp;data));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a lot to digest here, though, so let&amp;rsquo;s walk through it
line-by-line. First up in &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let mut core = Core::new().unwrap();
let handle = core.handle();
let addr = &amp;quot;www.rust-lang.org:443&amp;quot;.to_socket_addrs().unwrap().next().unwrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is our standard version of creating an event loop and adding a handle to it.
As an added piece here we&amp;rsquo;re using the standard library&amp;rsquo;s &lt;a href=&#34;https://doc.rust-lang.org/std/net/trait.ToSocketAddrs.html&#34;&gt;&lt;code&gt;to_socket_addrs&lt;/code&gt;&lt;/a&gt; to
resolve the hostname &lt;code&gt;www.rust-lang.org&lt;/code&gt; before our event loop runs. Note that
this DNS query happens synchronously, but there are a number of options for
asynchronous DNS queries in the ecosystem.&lt;/p&gt;

&lt;p&gt;Next up we see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let cx = TlsConnector::builder().unwrap().build().unwrap();
let socket = TcpStream::connect(&amp;amp;addr, &amp;amp;handle);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This uses the &lt;a href=&#34;https://github.com/sfackler/rust-native-tls&#34;&gt;&lt;code&gt;native-tls&lt;/code&gt;&lt;/a&gt; crate to create an instance of &lt;a href=&#34;https://docs.rs/native-tls/0.1/native_tls/struct.TlsConnector.html&#34;&gt;&lt;code&gt;TlsConnector&lt;/code&gt;&lt;/a&gt;
which is used to create new TLS connections. This is where TLS settings can
be configured, but for us all of the defaults will work fine.&lt;/p&gt;

&lt;p&gt;Afterwards, we issue a connection to &lt;code&gt;www.rust-lang.org&lt;/code&gt; to the previously
resolved address, using &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html#method.connect&#34;&gt;&lt;code&gt;TcpStream::connect&lt;/code&gt;&lt;/a&gt;. Note that this returns a future
as we don&amp;rsquo;t actually have the socket yet. It will be fully connected
at some later point in time.&lt;/p&gt;

&lt;p&gt;Once our socket is available, we need to perform three tasks to download the
rust-lang.org home page:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Perform a TLS handshake. The home page is only served over HTTPS, and we&amp;rsquo;ve
connected to port 443 and we&amp;rsquo;ll have to obey the TLS protocol.&lt;/li&gt;
&lt;li&gt;An HTTP &amp;lsquo;GET&amp;rsquo; request needs to be issued. For the purposes of this tutorial
we will write the request by hand, though in a serious program you would
use an HTTP client built on futures.&lt;/li&gt;
&lt;li&gt;Finally, we download the response by reading off all the data on the socket.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at each of these steps in detail, the first being:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let tls_handshake = socket.and_then(|socket| {
    let tls = cx.connect_async(&amp;quot;www.rust-lang.org&amp;quot;, socket);
    tls.map_err(|e| {
        io::Error::new(io::ErrorKind::Other, e)
    })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we use the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html&#34;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; trait to continue
building on the future returned by &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html#method.connect&#34;&gt;&lt;code&gt;TcpStream::connect&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt; method
takes a closure which receives the resolved value of this previous future. In
this case, &lt;code&gt;socket&lt;/code&gt; will have type &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html&#34;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt; closure,
however, will not run if &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html#method.connect&#34;&gt;&lt;code&gt;TcpStream::connect&lt;/code&gt;&lt;/a&gt; returned an error.&lt;/p&gt;

&lt;p&gt;Once we have our &lt;code&gt;socket&lt;/code&gt;, we use our previously created TLS connector to
initiate the TLS handshake through the &lt;a href=&#34;https://docs.rs/tokio-tls/0.1/tokio_tls/trait.TlsConnectorExt.html#tymethod.connect_async&#34;&gt;&lt;code&gt;connect_async&lt;/code&gt;&lt;/a&gt; method provided by the
&lt;a href=&#34;https://github.com/tokio-rs/tokio-tls&#34;&gt;&lt;code&gt;tokio-tls&lt;/code&gt;&lt;/a&gt; crate. The first argument is the domain name we&amp;rsquo;re connecting to,
with the I/O object as the second.&lt;/p&gt;

&lt;p&gt;Like with &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html#method.connect&#34;&gt;&lt;code&gt;TcpStream::connect&lt;/code&gt;&lt;/a&gt; from before, the &lt;a href=&#34;https://docs.rs/tokio-tls/0.1/tokio_tls/trait.TlsConnectorExt.html#tymethod.connect_async&#34;&gt;&lt;code&gt;connect_async&lt;/code&gt;&lt;/a&gt; method
returns a future. The actual TLS handshake may take some time as the
client and server need to perform some I/O, agree on certificates,
etc. Once resolved, however, the future will become a &lt;a href=&#34;https://docs.rs/tokio-tls/0.1/tokio_tls/struct.TlsStream.html&#34;&gt;&lt;code&gt;TlsStream&lt;/code&gt;&lt;/a&gt;,
similar to our previous &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/net/struct.TcpStream.html&#34;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt; combinator is doing some heavy lifting behind the
scenes here by ensuring that it executes futures in the right order
and keeping track of the futures in flight. Even better, the value
returned from &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt; itself implements &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html&#34;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;, so we can
keep chaining computations!&lt;/p&gt;

&lt;p&gt;Next up, we issue our HTTP request:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let request = tls_handshake.and_then(|socket| {
    tokio_io::io::write_all(socket, &amp;quot;\
        GET / HTTP/1.0\r\n\
        Host: www.rust-lang.org\r\n\
        \r\n\
    &amp;quot;.as_bytes())
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we take the future from the previous step, &lt;code&gt;tls_handshake&lt;/code&gt;, and
use &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt; again to continue the computation. The &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/io/fn.write_all.html&#34;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;
combinator writes the entirety of our HTTP request, issuing multiple
writes as necessary. Here we&amp;rsquo;re just doing a simple HTTP/1.0 request,
so there&amp;rsquo;s not much we need to write.&lt;/p&gt;

&lt;p&gt;The future returned by &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/io/fn.write_all.html&#34;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; will complete once all the data
has been written to the socket. Note that behind the scenes the
&lt;a href=&#34;https://docs.rs/tokio-tls/0.1/tokio_tls/struct.TlsStream.html&#34;&gt;&lt;code&gt;TlsStream&lt;/code&gt;&lt;/a&gt; will actually be encrypting all the data we write before
sending it to the underlying socket.&lt;/p&gt;

&lt;p&gt;And the third and final piece of our request looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let response = request.and_then(|(socket, _request)| {
    tokio_io::io::read_to_end(socket, Vec::new())
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The previous &lt;code&gt;request&lt;/code&gt; future is chained again to the final future,
the &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/io/fn.read_to_end.html&#34;&gt;&lt;code&gt;read_to_end&lt;/code&gt;&lt;/a&gt; combinator. This future will read all data from the
&lt;code&gt;socket&lt;/code&gt; provided and place it into the buffer provided (in this case an empty
one), and resolve to the buffer itself once the underlying connection hits EOF.&lt;/p&gt;

&lt;p&gt;Like before, though, reads from the &lt;code&gt;socket&lt;/code&gt; are actually decrypting data
received from the server under the covers, so we&amp;rsquo;re just reading the decrypted
version!&lt;/p&gt;

&lt;p&gt;If we were to return at this point in the program, you might be surprised to see
that nothing happens when it&amp;rsquo;s run! That&amp;rsquo;s because all we&amp;rsquo;ve done so
far is construct a futures-based computation; we haven&amp;rsquo;t actually run it. Up to
this point in the program we&amp;rsquo;ve done no I/O, issued no HTTP requests, etc.&lt;/p&gt;

&lt;p&gt;To actually execute our future and drive it to completion we&amp;rsquo;ll need to run the
event loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let (_socket, data) = core.run(response).unwrap();
println!(&amp;quot;{}&amp;quot;, String::from_utf8_lossy(&amp;amp;data));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we pass our &lt;code&gt;response&lt;/code&gt; future, our entire HTTP request, to
the event loop, &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Core.html#method.run&#34;&gt;asking it to resolve the future&lt;/a&gt;. The event loop will
then run until the future has been resolved, returning the result of the future,
which in this case is &lt;code&gt;io::Result&amp;lt;(TcpStream, Vec&amp;lt;u8&amp;gt;)&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that this &lt;code&gt;core.run(...)&lt;/code&gt; call will block the calling thread until the
future can itself be resolved. This means that &lt;code&gt;data&lt;/code&gt; here has type &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.
We then print it out to stdout as usual.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Example: an echo server using proto</title>
      <link>https://tokio-cn.github.io/legacy/getting-started/simple-server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/getting-started/simple-server/</guid>
      <description>

&lt;p&gt;To kick off our tour of Tokio, we&amp;rsquo;ll build a simple line-based echo server using
&lt;code&gt;tokio-proto&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ cargo new --bin echo-proto
cd echo-proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll need to add dependencies on the Tokio stack:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]
bytes = &amp;quot;0.4&amp;quot;
futures = &amp;quot;0.1&amp;quot;
tokio-io = &amp;quot;0.1&amp;quot;
tokio-core = &amp;quot;0.1&amp;quot;
tokio-proto = &amp;quot;0.1&amp;quot;
tokio-service = &amp;quot;0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and bring them into scope in &lt;code&gt;main.rs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate bytes;
extern crate futures;
extern crate tokio_io;
extern crate tokio_proto;
extern crate tokio_service;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;overview&#34;&gt;&lt;a href=&#34;#overview&#34;&gt;Overview&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;A server in &lt;code&gt;tokio-proto&lt;/code&gt; is made up of three distinct parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A &lt;strong&gt;transport&lt;/strong&gt;, which manages serialization of Rust request and response
types to the underlying socket. In this guide, we will implement this using
the &lt;code&gt;framed&lt;/code&gt; helper.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;strong&gt;protocol specification&lt;/strong&gt;, which puts together a codec and some basic
information about the protocol (is it
&lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-tokio/multiplex/&#34;&gt;multiplexed&lt;/a&gt;?
&lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-tokio/streaming/&#34;&gt;streaming&lt;/a&gt;?).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;strong&gt;service&lt;/strong&gt;, which says how to produce a response given a request. A
service is basically an asynchronous function. A service will contain
the stateful bits of a server like configuration information or a pool
of database connections.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each part can vary independently, so once you&amp;rsquo;ve implemented a protocol
(like HTTP), you can pair it with a number of different services.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how it&amp;rsquo;s done.&lt;/p&gt;

&lt;h2 id=&#34;implement-codec&#34;&gt;&lt;a href=&#34;#implement-codec&#34;&gt;Step 1: Implement a codec&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll start by implementing a codec for a simple line-based protocol,
where messages are arbitrary byte sequences delimited by &lt;code&gt;&#39;\n&#39;&lt;/code&gt;. To do
this, we&amp;rsquo;ll need a couple of tools from &lt;code&gt;tokio-io&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate bytes;
# extern crate tokio_io;
use std::io;
use std::str;
use bytes::BytesMut;
use tokio_io::codec::{Encoder, Decoder};
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, codecs may need local state, for example to record
information about incomplete decoding. We can get away without it,
though:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct LineCodec;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Codecs in Tokio implement the &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Encoder.html&#34;&gt;&lt;code&gt;Encoder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Decoder.html&#34;&gt;&lt;code&gt;Decoder&lt;/code&gt;&lt;/a&gt; traits from
&lt;a href=&#34;https://crates.io/crates/tokio-io&#34;&gt;tokio-io&lt;/a&gt;, which implements message encoding and decoding.  To start with,
we&amp;rsquo;ll need to specify the message type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;impl Decoder for LineCodec {
    type Item = String;
    type Error = io::Error;

    // ...
}

impl Encoder for LineCodec {
    type Item = String;
    type Error = io::Error;

    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; to represent lines, meaning that we&amp;rsquo;ll require UTF-8 encoding
for this line protocol.&lt;/p&gt;

&lt;p&gt;For our line-based protocol, decoding is straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate bytes;
# extern crate tokio_io;
#
# use std::io;
# use std::str;
# use bytes::BytesMut;
# use tokio_io::codec::{Encoder, Decoder};
#
# struct LineCodec;
#
impl Decoder for LineCodec {
    type Item = String;
    type Error = io::Error;

    fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt; {
        if let Some(i) = buf.iter().position(|&amp;amp;b| b == b&#39;\n&#39;) {
            // remove the serialized frame from the buffer.
            let line = buf.split_to(i);

            // Also remove the &#39;\n&#39;
            buf.split_to(1);

            // Turn this data into a UTF string and return it in a Frame.
            match str::from_utf8(&amp;amp;line) {
                Ok(s) =&amp;gt; Ok(Some(s.to_string())),
                Err(_) =&amp;gt; Err(io::Error::new(io::ErrorKind::Other,
                                             &amp;quot;invalid UTF-8&amp;quot;)),
            }
        } else {
            Ok(None)
        }
    }
}
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html&#34;&gt;&lt;code&gt;BytesMut&lt;/code&gt;&lt;/a&gt; used here provides simple but efficient buffer management; you
can think of it like &lt;code&gt;Arc&amp;lt;[u8]&amp;gt;&lt;/code&gt;, a reference-counted slice of bytes, with all
the details handled for you. Outgoing messages from the server use &lt;code&gt;Result&lt;/code&gt; in
order to convey service errors on the Rust side.&lt;/p&gt;

&lt;p&gt;When &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Decoder.html#tymethod.decode&#34;&gt;decoding&lt;/a&gt;, we are given an input &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html&#34;&gt;&lt;code&gt;BytesMut&lt;/code&gt;&lt;/a&gt; that contains a chunk of
unprocessed data, and we must try to extract the first complete message, if
there is one. If the buffer doesn&amp;rsquo;t contain a complete message, we return
&lt;code&gt;None&lt;/code&gt;, and the server will automatically fetch more data before trying to
decode again. The &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html#method.split_to&#34;&gt;&lt;code&gt;split_to&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html&#34;&gt;&lt;code&gt;BytesMut&lt;/code&gt;&lt;/a&gt; splits the buffer in two
at the given index, returning a new &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html&#34;&gt;&lt;code&gt;BytesMut&lt;/code&gt;&lt;/a&gt; instance corresponding to the
prefix ending at the index, and updating the existing &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html&#34;&gt;&lt;code&gt;BytesMut&lt;/code&gt;&lt;/a&gt; to contain
only the suffix. It&amp;rsquo;s the typical way to remove one complete message from the
input buffer.&lt;/p&gt;

&lt;p&gt;Encoding is even easier: you&amp;rsquo;re given mutable access to a &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html&#34;&gt;&lt;code&gt;BytesMut&lt;/code&gt;&lt;/a&gt;,
into which you serialize your output data. To keep things simple,
we won&amp;rsquo;t provide support for error responses:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate bytes;
# extern crate tokio_io;
#
# use std::io;
# use std::str;
# use bytes::BytesMut;
# use tokio_io::codec::{Encoder, Decoder};
#
# struct LineCodec;
#
impl Encoder for LineCodec {
    type Item = String;
    type Error = io::Error;

    fn encode(&amp;amp;mut self, msg: String, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
        buf.extend(msg.as_bytes());
        buf.extend(b&amp;quot;\n&amp;quot;);
        Ok(())
    }
}
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it for our codec.&lt;/p&gt;

&lt;h2 id=&#34;specify-protocol&#34;&gt;&lt;a href=&#34;#specify-protocol&#34;&gt;Step 2: Specify the protocol&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Next, we turn the codec into a full-blown protocol. The &lt;code&gt;tokio-proto&lt;/code&gt; crate is
equipped to deal with a variety of protocol styles, including
&lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-tokio/multiplex/&#34;&gt;multiplexed&lt;/a&gt; and
&lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-tokio/streaming/&#34;&gt;streaming&lt;/a&gt; protocols. For our line-based
protocol, though, we&amp;rsquo;ll use the simplest style: a pipelined, non-streaming
protocol:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_proto;
use tokio_proto::pipeline::ServerProto;
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with codecs, protocols can carry state, typically used for configuration. We
don&amp;rsquo;t need any configuration, so we&amp;rsquo;ll make another unit struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct LineProto;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Setting up a protocol requires just a bit of boilerplate, tying together our
chosen protocol style with the codec that we&amp;rsquo;ve built:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_proto;
# extern crate tokio_io;
# extern crate bytes;
#
# use std::io;
#
# use tokio_proto::pipeline::ServerProto;
use tokio_io::{AsyncRead, AsyncWrite};
use tokio_io::codec::Framed;
# use bytes::BytesMut;
# use tokio_io::codec::{Encoder, Decoder};
#
# struct LineCodec;
#
# impl Decoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt; {
#       if let Some(i) = buf.iter().position(|&amp;amp;b| b == b&#39;\n&#39;) {
#           // remove the serialized frame from the buffer.
#           let line = buf.split_to(i);
#
#           // Also remove the &#39;\n&#39;
#           buf.split_to(1);
#
#           // Turn this data into a UTF string and return it in a Frame.
#           match std::str::from_utf8(&amp;amp;line) {
#               Ok(s) =&amp;gt; Ok(Some(s.to_string())),
#               Err(_) =&amp;gt; Err(io::Error::new(io::ErrorKind::Other,
#                                            &amp;quot;invalid UTF-8&amp;quot;)),
#           }
#       } else {
#           Ok(None)
#       }
#   }
# }
#
# impl Encoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn encode(&amp;amp;mut self, msg: String, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
#       buf.extend(msg.as_bytes());
#       buf.extend(b&amp;quot;\n&amp;quot;);
#       Ok(())
#   }
# }
#
# struct LineProto;

impl&amp;lt;T: AsyncRead + AsyncWrite + &#39;static&amp;gt; ServerProto&amp;lt;T&amp;gt; for LineProto {
    // For this protocol style, `Request` matches the `Item` type of the codec&#39;s `Decoder`
    type Request = String;

    // For this protocol style, `Response` matches the `Item` type of the codec&#39;s `Encoder`
    type Response = String;

    // A bit of boilerplate to hook in the codec:
    type Transport = Framed&amp;lt;T, LineCodec&amp;gt;;
    type BindTransport = Result&amp;lt;Self::Transport, io::Error&amp;gt;;
    fn bind_transport(&amp;amp;self, io: T) -&amp;gt; Self::BindTransport {
        Ok(io.framed(LineCodec))
    }
}
#
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implement-service&#34;&gt;&lt;a href=&#34;#implement-service&#34;&gt;Step 3: Implement a service&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;At this point, we&amp;rsquo;ve built a generic line-based protocol. To actually &lt;em&gt;use&lt;/em&gt; this
protocol, we need to pair it with a &lt;em&gt;service&lt;/em&gt; that says how to respond to requests.
The &lt;code&gt;tokio-service&lt;/code&gt; crate provides a &lt;code&gt;Service&lt;/code&gt; trait for just this purpose:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_service;
use tokio_service::Service;
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with the other components we&amp;rsquo;ve built, in general a service may have data
associated with it. The service we want for this example just echos its input,
so no additional data is needed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub struct Echo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At its core, a service is an &lt;em&gt;asynchronous (non-blocking) function&lt;/em&gt; from
requests to responses.  We&amp;rsquo;ll have more to say about asynchronous programming in
the next guide; the only thing to know right now is that Tokio uses &lt;em&gt;futures&lt;/em&gt;
for asynchronous code, through the &lt;code&gt;Future&lt;/code&gt; trait. You can think of a future as
an asynchronous version of &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s bring the basics into scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate futures;
use futures::{future, Future};
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our echo service, we don&amp;rsquo;t need to do any I/O to produce a response for a
request. So we use &lt;code&gt;future::ok&lt;/code&gt; to make a future that immediately returns a
value&amp;mdash;in this case, returning the request immediately back as a successful
response. To keep things simple, we&amp;rsquo;ll also box the future into a trait object,
which allows us to use a trait object type to define our service, no matter
what future we actually use inside&amp;mdash;more on those tradeoffs later!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_service;
# extern crate futures;
#
# use std::io;
# use tokio_service::Service;
# use futures::{future, Future};
#
# struct Echo;
#
impl Service for Echo {
    // These types must match the corresponding protocol types:
    type Request = String;
    type Response = String;

    // For non-streaming protocols, service errors are always io::Error
    type Error = io::Error;

    // The future for computing the response; box it for simplicity.
    type Future = Box&amp;lt;Future&amp;lt;Item = Self::Response, Error =  Self::Error&amp;gt;&amp;gt;;

    // Produce a future for computing a response from a request.
    fn call(&amp;amp;self, req: Self::Request) -&amp;gt; Self::Future {
        // In this case, the response is immediate.
        Box::new(future::ok(req))
    }
}
#
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configure-and-run&#34;&gt;&lt;a href=&#34;#configure-and-run&#34;&gt;We&amp;rsquo;re done&amp;mdash;now configure and run!&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;With that, we have the ingredients necessary for a full-blown server: a general
protocol, and a particular service to provide on it. All that remains is to
actually configure and launch the server, which we&amp;rsquo;ll do using the &lt;code&gt;TcpServer&lt;/code&gt;
builder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,no_run&#34;&gt;# extern crate tokio_proto;
# extern crate tokio_core;
# extern crate tokio_io;
# extern crate futures;
# extern crate tokio_service;
# extern crate bytes;
#
# use std::io;
#
# use futures::{future, Future};
# use tokio_io::{AsyncRead, AsyncWrite};
# use tokio_io::codec::{Framed, Encoder, Decoder};
# use bytes::BytesMut;
use tokio_proto::TcpServer;
# use tokio_proto::pipeline::ServerProto;
# use tokio_service::Service;
#
# struct LineCodec;
#
# impl Encoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn encode(&amp;amp;mut self, msg: String, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
#       buf.extend(msg.as_bytes());
#       buf.extend(b&amp;quot;\n&amp;quot;);
#       Ok(())
#   }
# }
#
# impl Decoder for LineCodec {
#   type Item = String;
#   type Error = io::Error;
#
#   fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;Option&amp;lt;String&amp;gt;&amp;gt; {
#       if let Some(i) = buf.iter().position(|&amp;amp;b| b == b&#39;\n&#39;) {
#           // remove the serialized frame from the buffer.
#           let line = buf.split_to(i);
#
#           // Also remove the &#39;\n&#39;
#           buf.split_to(1);
#
#           // Turn this data into a UTF string and return it in a Frame.
#           match std::str::from_utf8(&amp;amp;line) {
#               Ok(s) =&amp;gt; Ok(Some(s.to_string())),
#               Err(_) =&amp;gt; Err(io::Error::new(io::ErrorKind::Other,
#                                            &amp;quot;invalid UTF-8&amp;quot;)),
#           }
#       } else {
#           Ok(None)
#       }
#   }
# }
#
# struct LineProto;
#
# impl&amp;lt;T: AsyncRead + AsyncWrite + &#39;static&amp;gt; ServerProto&amp;lt;T&amp;gt; for LineProto {
#     type Request = String;
#     type Response = String;
#     type Transport = Framed&amp;lt;T, LineCodec&amp;gt;;
#     type BindTransport = Result&amp;lt;Self::Transport, io::Error&amp;gt;;
#     fn bind_transport(&amp;amp;self, io: T) -&amp;gt; Self::BindTransport {
#         Ok(io.framed(LineCodec))
#     }
# }
#
# struct Echo;
#
# impl Service for Echo {
#     type Request = String;
#     type Response = String;
#     type Error = io::Error;
#     type Future = Box&amp;lt;Future&amp;lt;Item = Self::Response, Error = Self::Error&amp;gt;&amp;gt;;
#
#     fn call(&amp;amp;self, req: Self::Request) -&amp;gt; Self::Future {
#         Box::new(future::ok(req))
#     }
# }

fn main() {
    // Specify the localhost address
    let addr = &amp;quot;0.0.0.0:12345&amp;quot;.parse().unwrap();

    // The builder requires a protocol and an address
    let server = TcpServer::new(LineProto, addr);

    // We provide a way to *instantiate* the service for each new
    // connection; here, we just immediately return a new instance.
    server.serve(|| Ok(Echo));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can run this code and connect locally to try it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;~ $ telnet localhost 12345
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.
hello, world!
hello, world!
echo
echo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pairing&#34;&gt;&lt;a href=&#34;#pairing&#34;&gt;Pairing with another service&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;That was a fair amount of ceremony for a simple echo server. But most of what we
did&amp;mdash;the protocol specification&amp;mdash;is reusable. To prove it, let&amp;rsquo;s build a
service that echos its input in reverse:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_service;
# extern crate futures;
#
# use std::io;
# use tokio_service::Service;
# use futures::{future, Future};
#
struct EchoRev;

impl Service for EchoRev {
    type Request = String;
    type Response = String;
    type Error = io::Error;
    type Future = Box&amp;lt;Future&amp;lt;Item = Self::Response, Error = Self::Error&amp;gt;&amp;gt;;

    fn call(&amp;amp;self, req: Self::Request) -&amp;gt; Self::Future {
        let rev: String = req.chars()
            .rev()
            .collect();
        Box::new(future::ok(rev))
    }
}
#
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not too shabby. And now, if we replace &lt;code&gt;Echo&lt;/code&gt; with &lt;code&gt;EchoRev&lt;/code&gt; in the line &lt;code&gt;server.serve(|| Ok(Echo));&lt;/code&gt;, we&amp;rsquo;ll see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;~ $ telnet localhost 12345
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.
hello, world!
!dlrow ,olleh
echo
ohce
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Example: serving database content using proto</title>
      <link>https://tokio-cn.github.io/legacy/getting-started/db/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/getting-started/db/</guid>
      <description>

&lt;p&gt;In our previous example, an echo server, we didn&amp;rsquo;t leverage the fact that a
future can be returned from a &lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt;. Having just gotten our feet wet with
futures, however, let&amp;rsquo;s take a look at an example where we do just that. Here
we&amp;rsquo;ll be exploring a case in a well-known benchmark suite, &lt;a href=&#34;https://github.com/TechEmpower/FrameworkBenchmarks&#34;&gt;TechEmpower&lt;/a&gt;.
Specifically we&amp;rsquo;ll be looking at the &lt;a href=&#34;http://frameworkbenchmarks.readthedocs.io/en/latest/Project-Information/Framework-Tests/#single-database-query&#34;&gt;second benchmark&lt;/a&gt;, which entails that we
perform a few tasks:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Spin up an HTTP server, listening for HTTP requests to &lt;code&gt;/db&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;On each request, look up a random row in a database table.&lt;/li&gt;
&lt;li&gt;Once the row is loaded, serialize it to JSON, and send it back.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Sounds easy enough, let&amp;rsquo;s get started! If you&amp;rsquo;d like to &lt;a href=&#34;#complete&#34;&gt;skip ahead to the
complete code listing&lt;/a&gt; you can also do so.&lt;/p&gt;

&lt;p&gt;First up let&amp;rsquo;s discuss how we&amp;rsquo;re going to design the general architecture of
our program. We&amp;rsquo;ll primarily need an HTTP server and a database driver. For
this example we&amp;rsquo;ll be using &lt;a href=&#34;https://github.com/tokio-rs/tokio-minihttp&#34;&gt;&lt;code&gt;tokio-minihttp&lt;/code&gt;&lt;/a&gt;, a proof-of-concept pipelined
and asynchronous HTTP/1.1 server. This crate is not production ready nor will
it ever be, but it&amp;rsquo;s intended to show off an example of using &lt;a href=&#34;https://github.com/tokio-rs/tokio-proto&#34;&gt;&lt;code&gt;tokio-proto&lt;/code&gt;&lt;/a&gt;
with a simple HTTP implementation to hit the ground running.&lt;/p&gt;

&lt;p&gt;Next for our database driver we&amp;rsquo;re going to be using the &lt;a href=&#34;https://github.com/sfackler/rust-postgres&#34;&gt;&lt;code&gt;postgres&lt;/code&gt;&lt;/a&gt; crate on
&lt;a href=&#34;https://crates.io&#34;&gt;crates.io&lt;/a&gt;. This driver is &lt;em&gt;synchronous&lt;/em&gt; and will provide an excellent
opportunity to see how we bridge the synchronous and asynchronous worlds. We&amp;rsquo;ll
be using a thread pool to execute the database queries themselves in addition
to pooling database connections with the &lt;a href=&#34;https://github.com/sfackler/r2d2&#34;&gt;&lt;code&gt;r2d2&lt;/code&gt;&lt;/a&gt; crate from &lt;a href=&#34;https://crates.io&#34;&gt;crates.io&lt;/a&gt;. Note
that ideally we&amp;rsquo;d use an asynchronous database driver to avoid the overhead of
a thread pool, but at this time this isn&amp;rsquo;t available so we&amp;rsquo;ll stick to thread
pools.&lt;/p&gt;

&lt;p&gt;With a general layout in mind, let&amp;rsquo;s pull in our dependencies through
&lt;code&gt;Cargo.toml&lt;/code&gt;&amp;rsquo;s &lt;code&gt;[dependencies]&lt;/code&gt; section:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# basic dependencies from echo server before
futures = &amp;quot;0.1&amp;quot;
tokio-proto = &amp;quot;0.1&amp;quot;
tokio-service = &amp;quot;0.1&amp;quot;

# our toy HTTP implementation
tokio-minihttp = { git = &amp;quot;https://github.com/tokio-rs/tokio-minihttp&amp;quot; }

# database support with connection pooling
r2d2 = &amp;quot;0.7&amp;quot;
r2d2_postgres = &amp;quot;0.11&amp;quot;

# json
serde_derive = &amp;quot;1.0&amp;quot;
serde = &amp;quot;1.0&amp;quot;
serde_json = &amp;quot;1.0&amp;quot;

# misc support for thread pools, random numbers
futures-cpupool = &amp;quot;0.1&amp;quot;
rand = &amp;quot;0.3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next up, let&amp;rsquo;s get through the boilerplate of setting up our server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;fn main() {
    let addr = &amp;quot;127.0.0.1:8080&amp;quot;.parse().unwrap();
    let thread_pool = CpuPool::new(10);

    let db_url = &amp;quot;postgres://postgres@localhost&amp;quot;;
    let db_config = r2d2::Config::default();
    let db_manager = PostgresConnectionManager::new(db_url, TlsMode::None).unwrap();
    let db_pool = r2d2::Pool::new(db_config, db_manager).unwrap();

    TcpServer::new(tokio_minihttp::Http, addr).serve(move || {
        // ...
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;re first creating a thread pool to execute blocking database queries in
and then we&amp;rsquo;re creating a pool of database connections themselves, configured
with the &lt;a href=&#34;https://github.com/sfackler/r2d2&#34;&gt;&lt;code&gt;r2d2&lt;/code&gt;&lt;/a&gt; crate and its associated &lt;a href=&#34;https://github.com/sfackler/rust-postgres&#34;&gt;&lt;code&gt;postgres&lt;/code&gt;&lt;/a&gt; support. We&amp;rsquo;re just
sticking to the defaults for now but you can tune these parameters if you&amp;rsquo;d
like locally.&lt;/p&gt;

&lt;p&gt;Next up comes where we actually spin up our server:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;TcpServer::new(tokio_minihttp::Http, addr).serve(move || {
    // ...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;re using &lt;a href=&#34;https://tokio-rs.github.io/tokio-proto/tokio_proto/struct.TcpServer.html&#34;&gt;&lt;code&gt;TcpServer&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&#34;https://github.com/tokio-rs/tokio-proto&#34;&gt;&lt;code&gt;tokio-proto&lt;/code&gt;&lt;/a&gt; crate, and we&amp;rsquo;re
specifying the &lt;a href=&#34;https://tokio-rs.github.io/tokio-minihttp/tokio_minihttp/struct.Http.html&#34;&gt;&lt;code&gt;Http&lt;/code&gt;&lt;/a&gt; protocol implementation in the &lt;a href=&#34;https://github.com/tokio-rs/tokio-minihttp&#34;&gt;&lt;code&gt;tokio-minihttp&lt;/code&gt;&lt;/a&gt; crate.
Behind the scenes, this is going to create an event loop, configure it to accept
TCP connections, and then create a new service (with our closure) for each
connection. All connections will be handled by the &lt;a href=&#34;https://tokio-rs.github.io/tokio-minihttp/tokio_minihttp/struct.Http.html&#34;&gt;&lt;code&gt;Http&lt;/code&gt;&lt;/a&gt; protocol
implementation.&lt;/p&gt;

&lt;p&gt;With that out of the way, let&amp;rsquo;s take a look at what our actual service
is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;use tokio_minihttp::{Request, Response};

struct Server {
    thread_pool: CpuPool,
    db_pool: r2d2::Pool&amp;lt;r2d2_postgres::PostgresConnectionManager&amp;gt;,
}

impl Service for Server {
    type Request = Request;
    type Response = Response;

    // ...
}

// ...

TcpServer::new(tokio_minihttp::Http, addr).serve(move || {
    Ok(Server {
        thread_pool: thread_pool.clone(),
        db_pool: db_pool.clone(),
    })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our &lt;code&gt;Server&lt;/code&gt; is a &lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt; which will map &lt;a href=&#34;https://github.com/tokio-rs/tokio-minihttp&#34;&gt;&lt;code&gt;tokio-minihttp&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;https://tokio-rs.github.io/tokio-minihttp/tokio_minihttp/struct.Request.html&#34;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt;
type to a &lt;a href=&#34;https://tokio-rs.github.io/tokio-minihttp/tokio_minihttp/struct.Response.html&#34;&gt;&lt;code&gt;Response&lt;/code&gt;&lt;/a&gt; type. This means that we&amp;rsquo;ll be taking HTTP
requests and returning HTTP responses. When we actually construct a &lt;code&gt;Server&lt;/code&gt;
we&amp;rsquo;ll be sure to store handles to our &lt;a href=&#34;https://docs.rs/futures-cpupool/0.1/futures_cpupool/struct.CpuPool.html&#34;&gt;&lt;code&gt;CpuPool&lt;/code&gt;&lt;/a&gt; to execute work on along
with the pool of database connections as well.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;ve got our server up and running and ready to start servicing
requests, let&amp;rsquo;s start implementing the internals of &lt;a href=&#34;https://tokio-rs.github.io/tokio-service/tokio_service/trait.Service.html&#34;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt; for our &lt;code&gt;Server&lt;/code&gt;
type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;impl Service for Server {
    type Request = Request;
    type Response = Response;
    type Error = io::Error;
    type Future = Box&amp;lt;Future&amp;lt;Item = Response, Error = io::Error&amp;gt;&amp;gt;;

    fn call(&amp;amp;self, req: Request) -&amp;gt; Self::Future {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We saw &lt;code&gt;Request&lt;/code&gt; and &lt;code&gt;Response&lt;/code&gt; types from before, but here we&amp;rsquo;re also filling
out that we&amp;rsquo;re using &lt;code&gt;io::Error&lt;/code&gt; as our error value and our future will be a
boxed future (trait object). This allows us to flexibly define the future
internally.&lt;/p&gt;

&lt;p&gt;Well also need a &lt;code&gt;Message&lt;/code&gt; struct that we can use to serialize the row that we
will be getting from the database into json using &lt;code&gt;serde&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;#[derive(Serialize)]
struct Message {
    id: i32,
    body: String,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next up, let&amp;rsquo;s start implementing &lt;code&gt;call&lt;/code&gt;. First we can verify that the HTTP
request is indeed &lt;code&gt;/db&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;assert_eq!(req.path(), &amp;quot;/db&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ideally we&amp;rsquo;d implement a 404 handler for unrecognized paths, but for now we&amp;rsquo;ll
just panic if you request a different path. Next up let&amp;rsquo;s generate the id of
the row that we&amp;rsquo;re going to look up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let random_id = rand::thread_rng().gen_range(1, 5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now with this in hand comes the real meat. Let&amp;rsquo;s start executing our
database request on our thread pool:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let db = self.db_pool.clone();
let msg = self.thread_pool.spawn_fn(move || {
    let conn = db.get().map_err(|e| {
        io::Error::new(io::ErrorKind::Other, format!(&amp;quot;timeout: {}&amp;quot;, e))
    })?;

    // ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;re using our &lt;code&gt;thread_pool&lt;/code&gt; to spawn a unit of work. Inside this closure
we also capture &lt;code&gt;self.db_pool&lt;/code&gt;. The first thing we do is call &lt;code&gt;get&lt;/code&gt; which will
block the current thread until it can return a new database connection. In this
case though blocking threads is fine because we&amp;rsquo;re executing on a thread pool.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve got a database connection, we can now use &lt;a href=&#34;https://github.com/sfackler/rust-postgres&#34;&gt;&lt;code&gt;postgres&lt;/code&gt;&lt;/a&gt; to load a row
with the &lt;code&gt;random_id&lt;/code&gt; we generated earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let stmt = conn.prepare_cached(&amp;quot;SELECT * FROM greetings WHERE id = $1&amp;quot;)?;
let rows = stmt.query(&amp;amp;[&amp;amp;random_id])?;
let row = rows.get(0);

Ok(Message {
    id: row.get(&amp;quot;id&amp;quot;),
    body: row.get(&amp;quot;body&amp;quot;),
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/postgres/0.13/postgres/struct.Connection.html#method.prepare_cached&#34;&gt;&lt;code&gt;prepare_cached&lt;/code&gt;&lt;/a&gt; method should help us optimize this query slightly, and
otherwise we&amp;rsquo;re just picking the first row and deserializing it into a &lt;code&gt;Message&lt;/code&gt;
instance in &lt;code&gt;Rust&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;At this point we&amp;rsquo;ve finished up the work we&amp;rsquo;ll do on the thread pool so return
from &lt;a href=&#34;https://docs.rs/futures-cpupool/0.1/futures_cpupool/struct.CpuPool.html#method.spawn_fn&#34;&gt;&lt;code&gt;spawn_fn&lt;/code&gt;&lt;/a&gt; which will complete the future that it returned. To finish up
our implementation of &lt;code&gt;Service::call&lt;/code&gt; let&amp;rsquo;s take a look at the last piece:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;Box::new(msg.map(|msg| {
    let json = serde_json::to_string(&amp;amp;msg).unwrap();
    let mut response = Response::new();

    response.header(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;);
    response.body(&amp;amp;json);
    response
}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/futures-cpupool/0.1/futures_cpupool/struct.CpuPool.html#method.spawn_fn&#34;&gt;&lt;code&gt;spawn_fn&lt;/code&gt;&lt;/a&gt; function returned a &lt;a href=&#34;https://docs.rs/futures-cpupool/0.1/futures_cpupool/struct.CpuFuture.html&#34;&gt;&lt;code&gt;CpuFuture&lt;/code&gt;&lt;/a&gt; representing the loaded row
(&lt;code&gt;Message&lt;/code&gt;) above. Our service will take this loaded instance of &lt;code&gt;Message&lt;/code&gt; and
then transform it to an HTTP response by serializing it to JSON and filling
out a &lt;a href=&#34;https://tokio-rs.github.io/tokio-minihttp/tokio_minihttp/struct.Response.html&#34;&gt;&lt;code&gt;Response&lt;/code&gt;&lt;/a&gt; from the &lt;a href=&#34;https://github.com/tokio-rs/tokio-minihttp&#34;&gt;&lt;code&gt;tokio-minihttp&lt;/code&gt;&lt;/a&gt; crate. Finally, we see that a
&lt;code&gt;Box::new&lt;/code&gt; is used to package up this whole future into a trait object so
we can return it.&lt;/p&gt;

&lt;p&gt;Finally before we run the example, we need to set up the database to have a
&lt;code&gt;greetings&lt;/code&gt; table that we can query from. Run the following queries within the
&lt;code&gt;psql&lt;/code&gt; command to create and populate the table:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql,ignore&#34;&gt;CREATE TABLE greetings (
    id serial,
    body text
);

INSERT INTO greetings (body) VALUES
    (&#39;Hello&#39;),
    (&#39;&#39;),
    (&#39;Bonjour&#39;),
    (&#39;&#39;),
    (&#39;&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;complete&#34;&gt;&lt;a href=&#34;#complete&#34;&gt;Complete example&lt;/a&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,no_run&#34;&gt;# #![deny(warnings)]
# #![allow(bad_style)]

#[macro_use]
extern crate serde_derive;

extern crate futures;
extern crate futures_cpupool;
extern crate r2d2;
extern crate r2d2_postgres;
extern crate rand;
extern crate serde;
extern crate serde_json;
extern crate tokio_minihttp;
extern crate tokio_proto;
extern crate tokio_service;

use std::io;

use futures::Future;
use futures_cpupool::CpuPool;
use r2d2_postgres::{PostgresConnectionManager, TlsMode};
use rand::Rng;
use tokio_minihttp::{Request, Response};
use tokio_proto::TcpServer;
use tokio_service::Service;

#[derive(Serialize)]
struct Message {
    id: i32,
    body: String,
}

struct Server {
    thread_pool: CpuPool,
    db_pool: r2d2::Pool&amp;lt;r2d2_postgres::PostgresConnectionManager&amp;gt;,
}

impl Service for Server {
    type Request = Request;
    type Response = Response;
    type Error = io::Error;
    type Future = Box&amp;lt;Future&amp;lt;Item = Response, Error = io::Error&amp;gt;&amp;gt;;

    fn call(&amp;amp;self, req: Request) -&amp;gt; Self::Future {
        assert_eq!(req.path(), &amp;quot;/db&amp;quot;);

        let random_id = rand::thread_rng().gen_range(1, 5);
        let db = self.db_pool.clone();
        let msg = self.thread_pool.spawn_fn(move || {
            let conn = db.get().map_err(|e| {
                io::Error::new(io::ErrorKind::Other, format!(&amp;quot;timeout: {}&amp;quot;, e))
            })?;

            let stmt = conn.prepare_cached(&amp;quot;SELECT * FROM greetings WHERE id = $1&amp;quot;)?;
            let rows = stmt.query(&amp;amp;[&amp;amp;random_id])?;
            let row = rows.get(0);

            Ok(Message {
                id: row.get(&amp;quot;id&amp;quot;),
                body: row.get(&amp;quot;body&amp;quot;),
            })
        });

        Box::new(msg.map(|msg| {
            let json = serde_json::to_string(&amp;amp;msg).unwrap();
            let mut response = Response::new();

            response.header(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;);
            response.body(&amp;amp;json);
            response
        }))
    }
}

fn main() {
    let addr = &amp;quot;127.0.0.1:8080&amp;quot;.parse().unwrap();
    let thread_pool = CpuPool::new(10);

    let db_url = &amp;quot;postgres://postgres@localhost&amp;quot;;
    let db_config = r2d2::Config::default();
    let db_manager = PostgresConnectionManager::new(db_url, TlsMode::None).unwrap();
    let db_pool = r2d2::Pool::new(db_config, db_manager).unwrap();

    TcpServer::new(tokio_minihttp::Http, addr).serve(move || {
        Ok(Server {
            thread_pool: thread_pool.clone(),
            db_pool: db_pool.clone(),
        })
    })
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Futures</title>
      <link>https://tokio-cn.github.io/legacy/getting-started/futures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/getting-started/futures/</guid>
      <description>

&lt;p&gt;Tokio is fundamentally based on &lt;em&gt;asynchronous I/O&lt;/em&gt;. While you don&amp;rsquo;t need to have
a deep understanding of async I/O to use Tokio, it&amp;rsquo;s good to have the basic picture.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with a simple piece of I/O you might want to perform: reading a
certain number of bytes from a socket. Rust&amp;rsquo;s standard library provides a
function,
&lt;a href=&#34;https://static.rust-lang.org/doc/master/std/io/trait.Read.html#method.read_exact&#34;&gt;&lt;code&gt;read_exact&lt;/code&gt;&lt;/a&gt;,
to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;// reads 4096 bytes into `my_vec`
socket.read_exact(&amp;amp;mut my_vec[..4096]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Quick quiz&lt;/strong&gt;: what happens if the socket hasn&amp;rsquo;t received 4096 bytes yet?&lt;/p&gt;

&lt;p&gt;Since the standard library is based on &lt;em&gt;synchronous&lt;/em&gt; I/O, the answer is that the
calling thread is blocked, sleeping until more bytes are available. While that
works well in some contexts, it can be a problem for scaling up servers: if we
want to serve a large number of clients concurrently, but each request might
involve blocking a thread, then we&amp;rsquo;re going to need a large number of threads.&lt;/p&gt;

&lt;p&gt;In the asynchronous world, instead of blocking until requests can be completed,
we register that we &lt;em&gt;want&lt;/em&gt; to perform a certain request, and are later notified
when that request can be fulfilled. That means that we can use a single thread
to manage an arbitrary number of connections, with each connection using minimal
resources.&lt;/p&gt;

&lt;p&gt;Somehow, though, we&amp;rsquo;ve got to manage all of those in-flight requests. It&amp;rsquo;d be
nice if we could write code in terms of individual connections and operations,
and have all of that tracking and dispatching taken care of for us.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s where futures come in.&lt;/p&gt;

&lt;h2 id=&#34;futures&#34;&gt;&lt;a href=&#34;#futures&#34;&gt;Futures&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;A future is a value that&amp;rsquo;s in the process of being computed, but might not be
ready yet. Usually, the future becomes &lt;em&gt;complete&lt;/em&gt; (the value is ready) due to an
event happening somewhere else. While we&amp;rsquo;ve been looking at things from the
perspective of basic I/O, you can use a future to represent a wide range of
events, e.g.:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;A database query&lt;/strong&gt; that&amp;rsquo;s executing in a thread pool. When the query finishes,
the future is completed, and its value is the result of the query.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;An RPC invocation&lt;/strong&gt; to a server. When the server replies, the future is
completed, and its value is the server&amp;rsquo;s response.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;A timeout&lt;/strong&gt;. When time is up, the future is completed, and its value is
&lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;A long-running CPU-intensive task&lt;/strong&gt;, running on a thread pool. When the task
finishes, the future is completed, and its value is the return value of the
task.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Reading bytes from a socket&lt;/strong&gt;. When the bytes are ready, the future is completed
&amp;ndash; and depending on the buffering strategy, the bytes might be returned
directly, or written as a side-effect into some existing buffer.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In short, futures are applicable to asynchronous events of all shapes and
sizes. The asynchrony is reflected in the fact that you get a &lt;em&gt;future&lt;/em&gt; right
away, without blocking, even though the &lt;em&gt;value&lt;/em&gt; the future represents will
become ready only at some unknown time in the&amp;hellip; future.&lt;/p&gt;

&lt;h4 id=&#34;simple-example&#34;&gt;&lt;a href=&#34;#simple-example&#34;&gt;A simple example&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s make this concrete with an example: we&amp;rsquo;ll take a long-running computation
and add a timeout to it using futures.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cargo new --bin prime-timeout
cd prime-timeout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;ll bring in futures and a couple additional tools on top:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[dependencies]
futures = &amp;quot;0.1&amp;quot;
futures-cpupool = &amp;quot;0.1&amp;quot;
tokio-timer = &amp;quot;0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our lengthy computation, we&amp;rsquo;ll inefficiently confirm that a large prime
number is prime:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;const BIG_PRIME: u64 = 15485867;

// checks whether a number is prime, slowly
fn is_prime(num: u64) -&amp;gt; bool {
    for i in 2..num {
        if num % i == 0 { return false }
    }
    true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;synchronous-version&#34;&gt;&lt;a href=&#34;#synchronous-version&#34;&gt;Synchronous version&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;Before we use futures, here&amp;rsquo;s how we&amp;rsquo;d run this computation synchronously&amp;mdash;we
just call the function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# const BIG_PRIME: u64 = 1;
# fn is_prime(num: u64) -&amp;gt; bool { true }
// Synchronous version
fn main() {
    if is_prime(BIG_PRIME) {
        println!(&amp;quot;Prime&amp;quot;);
    } else {
        println!(&amp;quot;Not prime&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The effect is that the main thread is blocked until the computation finishes,
and then it prints out the result.&lt;/p&gt;

&lt;h5 id=&#34;asynchronous-version&#34;&gt;&lt;a href=&#34;#asynchronous-version&#34;&gt;Asynchronous version&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;Now let&amp;rsquo;s use futures and a thread pool to launch the computation
asynchronously:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate futures;
extern crate futures_cpupool;

use futures::Future;
use futures_cpupool::CpuPool;

# const BIG_PRIME: u64 = 1;
# fn is_prime(num: u64) -&amp;gt; bool { true }

fn main() {
    // set up a thread pool
    let pool = CpuPool::new_num_cpus();

    // spawn our computation, getting back a *future* of the answer
    let prime_future = pool.spawn_fn(|| {
        let prime = is_prime(BIG_PRIME);

        // For reasons we&#39;ll see later, we need to return a Result here
        let res: Result&amp;lt;bool, ()&amp;gt; = Ok(prime);
        res
    });

    println!(&amp;quot;Created the future&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version of the code pushes work onto a thread pool, and &lt;em&gt;immediately&lt;/em&gt;
returns a future, &lt;code&gt;prime_future&lt;/code&gt;. Thus, we&amp;rsquo;ll see &lt;code&gt;Created the future&lt;/code&gt; on the
console right away, while the primality test is done in the background. Of
course, this isn&amp;rsquo;t so useful&amp;mdash;we&amp;rsquo;ve thrown away the answer!&lt;/p&gt;

&lt;p&gt;Even though futures are asynchronous, you always have the option of treating
them synchronously, by &lt;em&gt;waiting&lt;/em&gt; for completion:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate futures;
# fn main() {
# use futures::Future;
// ...

println!(&amp;quot;Created the future&amp;quot;);

// unwrap here since we know the result is Ok
# let prime_future = futures::future::ok::&amp;lt;bool, ()&amp;gt;(true);
if prime_future.wait().unwrap() {
    println!(&amp;quot;Prime&amp;quot;);
} else {
    println!(&amp;quot;Not prime&amp;quot;);
}
# }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.wait&#34;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;
isn&amp;rsquo;t very commonly used in practice, it&amp;rsquo;s a nice illustration of the difference
between a future (like &lt;code&gt;prime_future&lt;/code&gt;) and the value it produces; the future is
returned right away, allowing you to do additional work concurrently (like
printing a message, here), and retrieve the value later on.&lt;/p&gt;

&lt;h5 id=&#34;adding-a-timeout&#34;&gt;&lt;a href=&#34;#adding-a-timeout&#34;&gt;Adding a timeout&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;So far this example isn&amp;rsquo;t terribly interesting, since there are simpler ways to
work with thread pools. But one strength of futures is their ability to
&lt;em&gt;combine&lt;/em&gt;. We&amp;rsquo;ll show this off by combining the thread pool future with a
timeout future:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;extern crate futures;
extern crate futures_cpupool;
extern crate tokio_timer;

use std::time::Duration;

use futures::Future;
use futures_cpupool::CpuPool;
use tokio_timer::Timer;

# const BIG_PRIME: u64 = 1;
# fn is_prime(num: u64) -&amp;gt; bool { true }

fn main() {
    let pool = CpuPool::new_num_cpus();
    let timer = Timer::default();

    // a future that resolves to Err after a timeout
    let timeout = timer.sleep(Duration::from_millis(750))
        .then(|_| Err(()));

    // a future that resolves to Ok with the primality result
    let prime = pool.spawn_fn(|| {
        Ok(is_prime(BIG_PRIME))
    });

    // a future that resolves to one of the above values -- whichever
    // completes first!
    let winner = timeout.select(prime).map(|(win, _)| win);

    // now block until we have a winner, then print what happened
    match winner.wait() {
        Ok(true) =&amp;gt; println!(&amp;quot;Prime&amp;quot;),
        Ok(false) =&amp;gt; println!(&amp;quot;Not prime&amp;quot;),
        Err(_) =&amp;gt; println!(&amp;quot;Timed out&amp;quot;),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we&amp;rsquo;re using a couple of additional methods on futures:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.then&#34;&gt;&lt;code&gt;then&lt;/code&gt;&lt;/a&gt;,
which in general allows you to sequence one future to run after getting the
value of another. In this case, we&amp;rsquo;re just using it to change the value
returned from the timeout future to &lt;code&gt;Err(())&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.select&#34;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;,
which combines two futures of the same type, allowing them to &amp;ldquo;race&amp;rdquo; to
completion. It yields a pair, where the first component is the value produced
by the first future to complete, and the second gives you the other future
back. Here, we just take the winning value.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While this example is simplistic, it gives some sense for how futures scale
up. Once you have a number of basic &amp;ldquo;events&amp;rdquo; set up as futures, you can combine
them in complex ways, and the futures library takes care of tracking all of the
relevant state and synchronization. For example here we&amp;rsquo;re behind the scenes
managing concurrent execution of &lt;code&gt;is_prime&lt;/code&gt; on a thread pool, the timer thread
managed by &lt;code&gt;Timer&lt;/code&gt;, and the main thread calling &lt;code&gt;wait&lt;/code&gt; all at once.&lt;/p&gt;

&lt;h5 id=&#34;whence-io&#34;&gt;&lt;a href=&#34;#whence-io&#34;&gt;Whence I/O?&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;We haven&amp;rsquo;t shown how to work directly with I/O events as futures. That&amp;rsquo;s because
I/O is a bit more complicated, and you often end up working with sibling
abstractions to futures: streams and sinks. These are all covered in subsequent
guides.&lt;/p&gt;

&lt;h2 id=&#34;the-future-trait&#34;&gt;&lt;a href=&#34;#the-future-trait&#34;&gt;The &lt;code&gt;Future&lt;/code&gt; trait&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;At this point, we&amp;rsquo;ve seen just a tiny bit of the futures API&amp;mdash;but what actually
&lt;em&gt;is&lt;/em&gt; a future?&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;futures&lt;/code&gt; library, a future is anything that implements the
&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html&#34;&gt;&lt;code&gt;Future&lt;/code&gt; trait&lt;/a&gt;,
which has a lot of similarities to the
&lt;a href=&#34;https://static.rust-lang.org/doc/master/std/iter/trait.Iterator.html&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt; trait&lt;/a&gt;
in the standard library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;trait Future {
    // The type of value that the future yields on successful completion.
    type Item;

    // The type of value that the future yields on failure.
    type Error;

    // The only required method, which attempts to complete the future.
    fn poll(&amp;amp;mut self) -&amp;gt; Poll&amp;lt;Self::Item, Self::Error&amp;gt;;

    // Blocks until completion.
    fn wait(self) -&amp;gt; Result&amp;lt;Self::Item, Self::Error&amp;gt; { ... }

    // Transforms the result of the future using the given closure.
    fn map&amp;lt;F, U&amp;gt;(self, f: F) -&amp;gt; Map&amp;lt;Self, F&amp;gt;
        where F: FnOnce(Self::Item) -&amp;gt; U { ... }

    // ... and many, many more provided methods
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since futures are primarily motivated by I/O, error handling is an important
concern baked in to the trait and its methods.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;poll&lt;/code&gt; method is the heart of the futures trait&amp;mdash;it&amp;rsquo;s how futures actually
do their work. However, it&amp;rsquo;s not generally called directly. Instead, you tend to
work through the other methods of the &lt;code&gt;Future&lt;/code&gt; trait (which are all default
methods).  You can find an in-depth explanation of &lt;code&gt;poll&lt;/code&gt; in &lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-futures/futures-model/&#34;&gt;the futures model
in depth&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So that&amp;rsquo;s the quick tour. In the next section, we&amp;rsquo;ll look at a more involved
example: hooking up a database to the &lt;a href=&#34;../simple-server&#34;&gt;line-based protocol&lt;/a&gt; we
developed earlier.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>High-level I/O using core</title>
      <link>https://tokio-cn.github.io/legacy/getting-started/core/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/getting-started/core/</guid>
      <description>

&lt;p&gt;At this point, we&amp;rsquo;ve got a pretty solid grasp of what event loops are and how
&lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.Core.html&#34;&gt;&lt;code&gt;Core&lt;/code&gt;&lt;/a&gt; allows us to work with futures on an event loop. Let&amp;rsquo;s get down to
business and do some I/O! In this section, we&amp;rsquo;ll cover &amp;ldquo;high-level&amp;rdquo; I/O with
&lt;code&gt;tokio-io&lt;/code&gt; using the primitives from &lt;code&gt;tokio-core&lt;/code&gt; as futures, streams and
sinks. A &lt;a href=&#34;../../going-deeper/core-low-level&#34;&gt;later section&lt;/a&gt; will explain how to
work at the lowest level with &lt;a href=&#34;https://docs.rs/tokio-core/0.1&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt;, which gives you maximal control
over things like buffering strategy.&lt;/p&gt;

&lt;h3 id=&#34;concrete-io&#34;&gt;&lt;a href=&#34;#concrete-io&#34;&gt;Concrete I/O types&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/tokio-core/0.1&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt; crate doesn&amp;rsquo;t provide a full suite of I/O primitives; it&amp;rsquo;s
focused on TCP/UDP networking types. That&amp;rsquo;s because these are the only I/O
objects that you can work with asynchronously across Rust&amp;rsquo;s main platforms.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/&#34;&gt;&lt;code&gt;tokio_core::net&lt;/code&gt;&lt;/a&gt; module you&amp;rsquo;ll find types like
&lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.TcpListener.html&#34;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; we&amp;rsquo;ve been using in examples prior, &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.TcpStream.html&#34;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;, and
&lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.UdpSocket.html&#34;&gt;&lt;code&gt;UdpSocket&lt;/code&gt;&lt;/a&gt;. These networking types serve as the core foundation for most
servers and should look very similar to their &lt;a href=&#34;https://doc.rust-lang.org/std/net/&#34;&gt;standard library
counterparts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The main difference between &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/&#34;&gt;&lt;code&gt;tokio_core::net&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://doc.rust-lang.org/std/net/&#34;&gt;&lt;code&gt;std::net&lt;/code&gt;&lt;/a&gt; is that the
Tokio versions are all &lt;em&gt;non-blocking&lt;/em&gt;. The &lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Read.html&#34;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;/&lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Write.html&#34;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; trait
implementations are not blocking and will return a &amp;ldquo;would block&amp;rdquo; error instead
of blocking (see the &lt;a href=&#34;../../going-deeper/core-low-level&#34;&gt;low-level I/O section&lt;/a&gt;
for more).  Similarly types are also enhanced with futures-aware methods such
as &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.TcpStream.html#method.connect&#34;&gt;&lt;code&gt;TcpStream::connect&lt;/code&gt;&lt;/a&gt; returning a future or &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.Incoming.html&#34;&gt;&lt;code&gt;TcpListener::incoming&lt;/code&gt;&lt;/a&gt;
returning a stream.&lt;/p&gt;

&lt;p&gt;Finally we&amp;rsquo;ll note that the concrete &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.TcpStream.html&#34;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; type also implements the
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html&#34;&gt;&lt;code&gt;AsyncRead&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncWrite.html&#34;&gt;&lt;code&gt;AsyncWrite&lt;/code&gt;&lt;/a&gt; traits from the &lt;a href=&#34;https://crates.io/crates/tokio-io&#34;&gt;tokio-io&lt;/a&gt; crate to gain access
to those combinators and such.&lt;/p&gt;

&lt;h3 id=&#34;io-helpers&#34;&gt;&lt;a href=&#34;#io-helpers&#34;&gt;I/O helpers&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The Tokio ecosystem comes with a &lt;a href=&#34;https://crates.io/crates/tokio-io&#34;&gt;tokio-io&lt;/a&gt; crate which provides abstractions
for I/O independent of the underlying runtime. This crate primarily defines two
traits, &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html&#34;&gt;&lt;code&gt;AsyncRead&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncWrite.html&#34;&gt;&lt;code&gt;AsyncWrite&lt;/code&gt;&lt;/a&gt;, which serve as the foundation for
streaming byte I/O throughout the rest of the ecosystem.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html&#34;&gt;&lt;code&gt;AsyncRead&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncWrite.html&#34;&gt;&lt;code&gt;AsyncWrite&lt;/code&gt;&lt;/a&gt; traits are intended to be similar to their
std counterparts (and inherit from them) but also clearly demarcate &amp;ldquo;futures
aware&amp;rdquo; I/O types. This means that they follow the tokio-io mandated properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Calls to &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; are &lt;strong&gt;nonblocking&lt;/strong&gt;, they never block the calling
thread.&lt;/li&gt;
&lt;li&gt;If a call would otherwise block then an error is returned with the kind of
&lt;code&gt;WouldBlock&lt;/code&gt;. If this happens then the current future&amp;rsquo;s task is scheduled to
receive a notification (an unpark) when the I/O is ready again.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll explore these facets in more detail in &lt;a href=&#34;../../going-deeper/core-low-level&#34;&gt;later
sections&lt;/a&gt;, but for now we can look at some of
the other goodies that these traits give us. First we&amp;rsquo;ll notice the
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.read_buf&#34;&gt;&lt;code&gt;read_buf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncWrite.html#method.write_buf&#34;&gt;&lt;code&gt;write_buf&lt;/code&gt;&lt;/a&gt; functions which allow easy integration with the
&lt;a href=&#34;https://crates.io/crates/bytes&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; crate and multiple buffering strategies. The
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.split&#34;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method also assists in working with &amp;ldquo;halves&amp;rdquo; of a
stream independently. This method essentially takes an &lt;code&gt;AsyncRead + AsyncWrite&lt;/code&gt;
object and returns two objects that implement &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html&#34;&gt;&lt;code&gt;AsyncRead&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncWrite.html&#34;&gt;&lt;code&gt;AsyncWrite&lt;/code&gt;&lt;/a&gt;,
respectively. This can often be convenient when working with futures to ensure
ownership is managed correctly.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/io/index.html&#34;&gt;&lt;code&gt;tokio_io::io&lt;/code&gt;&lt;/a&gt; module also provides a number of utilities and helpers for
working with I/O objects as futures. When using these utilities, it&amp;rsquo;s important
to remember a few points:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They only work with &amp;ldquo;futures aware&amp;rdquo; objects that implement &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html&#34;&gt;&lt;code&gt;AsyncRead&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncWrite.html&#34;&gt;&lt;code&gt;AsyncWrite&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;They are intended to be &lt;em&gt;helpers&lt;/em&gt;. For your particular use case they may not
always be the most efficient. The helpers are intended to help you hit the
ground running and can easily be replaced with application-specific logic in
the future if necessary.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/io/index.html&#34;&gt;&lt;code&gt;tokio_io::io&lt;/code&gt;&lt;/a&gt; module provides a suite of helper functions to express I/O
operations as futures, such as &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/io/fn.read_to_end.html&#34;&gt;&lt;code&gt;read_to_end&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/io/fn.write_all.html&#34;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;. The functions
take the I/O object, and any relevant buffers, by value. The resulting futures
then yield back ownership of these values, so you can continue using them.
Threading ownership in this way is necessary in part because futures are often
required to be &lt;code&gt;&#39;static&lt;/code&gt;, making borrowing impossible.&lt;/p&gt;

&lt;h3 id=&#34;io-codecs&#34;&gt;&lt;a href=&#34;#io-codecs&#34;&gt;I/O codecs and framing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Working with a raw stream of bytes isn&amp;rsquo;t always the easiest thing to do,
especially in an asynchronous context. Additionally, many protocols aren&amp;rsquo;t
really byte-oriented but rather have a higher level &amp;ldquo;framing&amp;rdquo; they&amp;rsquo;re using.
Often this means that abstractions like &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html&#34;&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/a&gt; from the
&lt;a href=&#34;https://docs.rs/futures/0.1&#34;&gt;&lt;code&gt;futures&lt;/code&gt;&lt;/a&gt; crate are a perfect fit for a protocol, and you just need to somehow
get a stream of bytes into a &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html&#34;&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/a&gt;. Thankfully, [&lt;code&gt;tokio-io&lt;/code&gt;]
helps you do exactly this with a method of the &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html&#34;&gt;&lt;code&gt;AsyncRead&lt;/code&gt;&lt;/a&gt; trait,
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.framed&#34;&gt;&lt;code&gt;AsyncRead::framed&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.framed&#34;&gt;&lt;code&gt;AsyncRead::framed&lt;/code&gt;&lt;/a&gt; method takes a type, which implements the &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Encoder.html&#34;&gt;&lt;code&gt;Encoder&lt;/code&gt;&lt;/a&gt;
and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Decoder.html&#34;&gt;&lt;code&gt;Decoder&lt;/code&gt;&lt;/a&gt; traits, and defines how to take a stream and sink of bytes
to a literal &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html&#34;&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/a&gt; implementation. This method will return a
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/struct.Framed.html&#34;&gt;&lt;code&gt;Framed&lt;/code&gt;&lt;/a&gt; which implements the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html&#34;&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; traits, using the
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Encoder.html&#34;&gt;&lt;code&gt;Encoder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Decoder.html&#34;&gt;&lt;code&gt;Decoder&lt;/code&gt;&lt;/a&gt; provided to decode and encode frames. Note that a
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/struct.Framed.html&#34;&gt;&lt;code&gt;Framed&lt;/code&gt;&lt;/a&gt; can be split with &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.split&#34;&gt;&lt;code&gt;Stream::split&lt;/code&gt;&lt;/a&gt; into two halves (like
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.split&#34;&gt;&lt;code&gt;AsyncRead::split&lt;/code&gt;&lt;/a&gt;) if necessary.&lt;/p&gt;

&lt;p&gt;As we saw &lt;a href=&#34;../simple-server&#34;&gt;much earlier&lt;/a&gt;, a &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Decoder.html&#34;&gt;&lt;code&gt;Decoder&lt;/code&gt;&lt;/a&gt; defines how to decode
data received on the I/O stream and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Encoder.html&#34;&gt;&lt;code&gt;Encoder&lt;/code&gt;&lt;/a&gt; how to encode frames back into
the I/O stream. This sort of operation requires some level of buffering, which
is typically quite a tricky topic in asynchronous I/O handling. The &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Decoder.html&#34;&gt;&lt;code&gt;Decoder&lt;/code&gt;&lt;/a&gt;
trait provides an &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html&#34;&gt;&lt;code&gt;BytesMut&lt;/code&gt;&lt;/a&gt; for decoding, which is essentially a
reference-counted owned list of bytes. This allows efficient extraction of
slices of the buffer through &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html#method.split_to&#34;&gt;&lt;code&gt;BytesMut::split_to&lt;/code&gt;&lt;/a&gt;. For &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Encoder.html&#34;&gt;&lt;code&gt;Encoder&lt;/code&gt;&lt;/a&gt;
simply append bytes to the provided &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/struct.BytesMut.html&#34;&gt;&lt;code&gt;BytesMut&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As with other helpers in &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/io/index.html&#34;&gt;&lt;code&gt;tokio_io::io&lt;/code&gt;&lt;/a&gt; the &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Encoder.html&#34;&gt;&lt;code&gt;Encoder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Decoder.html&#34;&gt;&lt;code&gt;Decoder&lt;/code&gt;&lt;/a&gt;
traits may not perfectly suit your application, particularly with respect to
buffering strategies. Fear not, though, as the &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.framed&#34;&gt;&lt;code&gt;AsyncRead::framed&lt;/code&gt;&lt;/a&gt; method is
just meant to get you up and running quickly. Crates like &lt;a href=&#34;https://github.com/tokio-rs/tokio-proto&#34;&gt;&lt;code&gt;tokio-proto&lt;/code&gt;&lt;/a&gt; work
with a &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html&#34;&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/a&gt; directly (also referred to as &lt;a href=&#34;https://tokio-cn.github.io/docs/going-deeper/transports&#34;&gt;transports&lt;/a&gt;), so
you can swap out &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.framed&#34;&gt;&lt;code&gt;AsyncRead::framed&lt;/code&gt;&lt;/a&gt; with your own implementation if it
becomes a bottleneck.  You can even add complex protocol feature handling such
as ping / pong behavior.  This is described in &lt;a href=&#34;https://tokio-cn.github.io/docs/going-deeper/transports&#34;&gt;working with transports&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;datagrams&#34;&gt;&lt;a href=&#34;#datagrams&#34;&gt;Datagrams&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Note that most of this discussion has been around I/O or byte &lt;em&gt;streams&lt;/em&gt;, which
UDP importantly is not! To accommodate this, however, the &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.UdpSocket.html&#34;&gt;&lt;code&gt;UdpSocket&lt;/code&gt;&lt;/a&gt; type
also provides a number of methods for working with it conveniently:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/tokio-core/0.1.1/tokio_core/net/struct.UdpSocket.html#method.send_dgram&#34;&gt;&lt;code&gt;send_dgram&lt;/code&gt;&lt;/a&gt; allows you to express sending a datagram as a future, returning
an error if the entire datagram couldn&amp;rsquo;t be sent at once.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/tokio-core/0.1.1/tokio_core/net/struct.UdpSocket.html#method.recv_dgram&#34;&gt;&lt;code&gt;recv_dgram&lt;/code&gt;&lt;/a&gt; expresses reading a datagram into a buffer, yielding both the
buffer and the address it came from.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/tokio-core/0.1.1/tokio_core/net/struct.UdpSocket.html#method.framed&#34;&gt;&lt;code&gt;framed&lt;/code&gt;&lt;/a&gt; acts similarly to &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html#method.framed&#34;&gt;&lt;code&gt;AsyncRead::framed&lt;/code&gt;&lt;/a&gt; in
easing the transformation of a &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.UdpSocket.html&#34;&gt;&lt;code&gt;UdpSocket&lt;/code&gt;&lt;/a&gt; to a &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html&#34;&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/a&gt;.
Note that this method takes a &lt;a href=&#34;https://docs.rs/tokio-core/0.1.1/tokio_core/net/trait.UdpCodec.html&#34;&gt;&lt;code&gt;UdpCodec&lt;/code&gt;&lt;/a&gt; which differs from &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Encoder.html&#34;&gt;&lt;code&gt;Encoder&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/codec/trait.Decoder.html&#34;&gt;&lt;code&gt;Decoder&lt;/code&gt;&lt;/a&gt; to better suit datagrams instead of byte streams.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Larger examples</title>
      <link>https://tokio-cn.github.io/legacy/going-deeper-tokio/examples/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/going-deeper-tokio/examples/</guid>
      <description>&lt;p&gt;Often times when learning a new framework or if you&amp;rsquo;re just getting your feet
wet with async I/O it&amp;rsquo;s very helpful to look at a lot of examples. Tokio
certainly has no shortage of such ranging from small to large! Here we&amp;rsquo;ll
categorize some programs that are well commented and suitable to learn from. If
you&amp;rsquo;ve got your own example you&amp;rsquo;d like to see here feel free to send a PR to
update this list!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/tokio-rs/tokio-socks5/blob/master/src/main.rs&#34;&gt;A SOCKSv5 proxy server&lt;/a&gt; implemented at the &lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt;
layer. This server shows off a mixture of high and low level I/O using TCP
streams as well as shows off the asynchronous DNS library, &lt;a href=&#34;http://trust-dns.org/&#34;&gt;trust-dns&lt;/a&gt;. An
interesting optimization for this server is that there&amp;rsquo;s only one globally
allocated buffer through which all proxied data travels through, making it
quite efficient at buffer management.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/tokio-rs/tokio-line&#34;&gt;A line-based protocol for tokio-proto&lt;/a&gt; showcasing both pipelined
and multiplexed versions also with built-in servers/clients to see how they
interoperate together.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/tokio-rs/tokio-core/tree/master/examples&#34;&gt;Examples in &lt;code&gt;tokio-core&lt;/code&gt; itself&lt;/a&gt; should be well
documented and self-contained to play around with the abstractions in
&lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt;. These examples range from a &lt;a href=&#34;https://github.com/tokio-rs/tokio-core/blob/master/examples/chat.rs&#34;&gt;chat server&lt;/a&gt; to a small
&lt;a href=&#34;https://github.com/tokio-rs/tokio-core/blob/master/examples/connect.rs&#34;&gt;&lt;code&gt;nc&lt;/code&gt;-like program&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;re feeling a intrepid you can also explore the source code of &lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-tokio/third-party/&#34;&gt;third
party projects&lt;/a&gt; using Tokio, or &lt;a href=&#34;https://github.com/tokio-rs&#34;&gt;Tokio
itself&lt;/a&gt;! This is often a great way to see abstractions in action and poke
around in general.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Low-level I/O using core</title>
      <link>https://tokio-cn.github.io/legacy/going-deeper-tokio/core-low-level/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/going-deeper-tokio/core-low-level/</guid>
      <description>

&lt;p&gt;We&amp;rsquo;ve seen some examples of &lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/core/&#34;&gt;high level I/O&lt;/a&gt; with
&lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt;, but these aren&amp;rsquo;t quite always flexible enough to work with all
flavors of futures.  Often times the particulars of buffering strategy,
ownership, etc, may want to be tweaked.&lt;/p&gt;

&lt;p&gt;Here we&amp;rsquo;ll explore the low-level support that &lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt; provides as well as
how it expects I/O objects to work. This should be helpful if you&amp;rsquo;re
implementing your own I/O object or writing your own implementation of &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html&#34;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;
that internally performs I/O.&lt;/p&gt;

&lt;h2 id=&#34;io-patterns&#34;&gt;&lt;a href=&#34;#io-patterns&#34;&gt;I/O patterns&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;All I/O with &lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt; consistently adheres to two properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Operations are non-blocking. If an operation would otherwise block an error of
the &lt;code&gt;WouldBlock&lt;/code&gt; &lt;a href=&#34;https://doc.rust-lang.org/std/io/enum.ErrorKind.html&#34;&gt;error kind&lt;/a&gt; is returned.&lt;/li&gt;
&lt;li&gt;When a &lt;code&gt;WouldBlock&lt;/code&gt; error is returned, the current future task is scheduled to
receive a notification when the I/O object would otherwise be ready.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at some concrete examples with &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.TcpStream.html&#34;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;. The lowest level
of I/O that TCP streams support is the &lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Read.html&#34;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Write.html&#34;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits from the
standard library. Sure enough, we see a number of trait implementations for&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;impl Read for TcpStream
impl Write for TcpStream
impl&amp;lt;&#39;a&amp;gt; Read for &amp;amp;&#39;a TcpStream
impl&amp;lt;&#39;a&amp;gt; Write for &amp;amp;&#39;a TcpStream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In accordance with the two properties mentioned above, these implementations are
quite different than their standard library counterparts. They are all
&lt;em&gt;non-blocking&lt;/em&gt;; rather than blocking the current thread for data to arrive or
for there to be room to write, they will return &lt;code&gt;WouldBlock&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second property though is a little more subtle. It transitively implies
that &lt;strong&gt;all Tokio I/O objects can only be used within the context of a task&lt;/strong&gt;,
which generally means within &lt;code&gt;poll&lt;/code&gt;-like methods. (This task context is tracked
implicitly using thread-local storage; see the &lt;a href=&#34;https://tokio-cn.github.io/docs/getting-started/tasks/&#34;&gt;section on tasks&lt;/a&gt;
for more detail.) With this property, though, we can get ergonomic and efficient
management of &amp;ldquo;blocking&amp;rdquo; the current &lt;em&gt;task&lt;/em&gt; waiting for I/O to complete. In
other words, we get a lightweight threading model.&lt;/p&gt;

&lt;p&gt;Recall in the &lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-futures/futures-model/&#34;&gt;futures model&lt;/a&gt; section we
learned that whenever a future returns &lt;code&gt;NotReady&lt;/code&gt; it will schedule the current
task to receive a notification when it would otherwise become ready. Basic I/O
operations in Tokio work in a similar way. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let mut buf = [0; 128];
let res = tcp_stream.read(&amp;amp;mut buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;re just reading data from a TCP stream into a stack local buffer. We&amp;rsquo;re
guaranteed that &lt;code&gt;read&lt;/code&gt; will return immediately, and it can return with one of
three values:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Ok(n)&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; bytes were successfully read from the stream into &lt;code&gt;buf&lt;/code&gt;.
This means that data was immediately available and we didn&amp;rsquo;t have to block
waiting for it. We can now proceed with the data we&amp;rsquo;ve read and process it as
usual.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Err(e) if e.kind() == ErrorKind::WouldBlock&lt;/code&gt; meaning that the operation did
not fail per se but otherwise could not complete. This error indicates that
there may eventually be more data to read but it&amp;rsquo;s not available at this time.
Like with a future returning &lt;code&gt;NotReady&lt;/code&gt;, this also means that the current task
has been scheduled for wakeup when data is ready. When the &lt;code&gt;tcp_stream&lt;/code&gt;
receives some more data, the task will be woken up and the outer future can
resume.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Err(e)&lt;/code&gt; means that an otherwise &amp;ldquo;real&amp;rdquo; I/O error happened. This typically
should be communicated up the stack to indicate that a potentially fatal error
on the TCP connection has occurred.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Although we&amp;rsquo;ve been talking about the &lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Read.html&#34;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://doc.rust-lang.org/std/io/trait.Write.html&#34;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits so far these
two principles of non-blocking and &amp;ldquo;futures aware&amp;rdquo; apply to all I/O that
&lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt; performs. This includes other examples such as accepting TCP
sockets from a listener or sending a datagram on a UDP socket.&lt;/p&gt;

&lt;h2 id=&#34;async-read-write&#34;&gt;&lt;a href=&#34;#async-read-write&#34;&gt;&lt;code&gt;AsyncRead&lt;/code&gt; and &lt;code&gt;AsyncWrite&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;While some implementations of &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Write&lt;/code&gt; provide the required properties
described above, not all do. For example, none of the file I/O operations in std
will work on the event loop even though they implement &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Write&lt;/code&gt;.
However, &lt;code&gt;tokio-io&lt;/code&gt; provides &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncRead.html&#34;&gt;&lt;code&gt;AsyncRead&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/trait.AsyncWrite.html&#34;&gt;&lt;code&gt;AsyncWrite&lt;/code&gt;&lt;/a&gt; traits which
extend &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Write&lt;/code&gt; respectively. Implementations of these traits
guarantee that they satisfy the required properties to work with the event loop.&lt;/p&gt;

&lt;p&gt;So, looking at &lt;code&gt;tokio_core::net::TcpStream&lt;/code&gt; again, you will also see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;impl AsyncRead for TcpStream
impl AsyncWrite for TcpStream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides just indicating that they work with the event loop, they also provide a
number of additional helper functions, some of which we have seen before. See
the full &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/&#34;&gt;API documentation&lt;/a&gt; for more details.&lt;/p&gt;

&lt;h2 id=&#34;buffering&#34;&gt;&lt;a href=&#34;#buffering&#34;&gt;Buffering strategies&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The core types in &lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt; do not bake in any particular buffering
strategy and should be amenable to working with whatever&amp;rsquo;s appropriate for your
application. All methods that read and write bytes work over slices which can be
used to get as close to the raw syscalls as possible. There are also &lt;code&gt;read_buf&lt;/code&gt;
and &lt;code&gt;write_buf&lt;/code&gt; functions which are generic over &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/trait.Buf.html&#34;&gt;&lt;code&gt;Buf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/bytes/0.4/bytes/trait.BufMut.html&#34;&gt;&lt;code&gt;BufMut&lt;/code&gt;&lt;/a&gt;,
allowing for various buffering strategies to interopt.&lt;/p&gt;

&lt;p&gt;Further buffering strategies can be found in the &lt;a href=&#34;https://github.com/carllerche/bytes&#34;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; crate on &lt;a href=&#34;https://crates.io&#34;&gt;crates.io&lt;/a&gt;
which should compose well with the slice-taking methods of &lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt;. Note
that all methods that read bytes in &lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt; are guaranteed to not attempt
to read the slice of data passed in and will accurately report sizes read. As a
result it should be safe to pass slices of uninitialized data to read methods if
necessary.&lt;/p&gt;

&lt;h2 id=&#34;custom-io&#34;&gt;&lt;a href=&#34;#custom-io&#34;&gt;Creating your own I/O object&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Currently &lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt; only provides three standard networking types available
on all platforms: &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.UdpSocket.html&#34;&gt;&lt;code&gt;UdpSocket&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.TcpListener.html&#34;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.TcpStream.html&#34;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt;. While
encompassing a wide range of use cases these aren&amp;rsquo;t the only objects that can
work with async I/O! A final type, &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html&#34;&gt;&lt;code&gt;PollEvented&lt;/code&gt;&lt;/a&gt;, is provided to enable custom
I/O objects to be registered with the event loop and receive the same treatment
as the networking types.&lt;/p&gt;

&lt;p&gt;Recall that there are two guarantees required and provided by I/O objects in
&lt;code&gt;tokio-core&lt;/code&gt;: operations are nonblocking and &amp;ldquo;futures aware.&amp;rdquo; The
&lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html&#34;&gt;&lt;code&gt;PollEvented&lt;/code&gt;&lt;/a&gt; type implements the &amp;ldquo;futures aware&amp;rdquo; guarantee and is typically
provided a nonblocking I/O object internally. This means that to implement your
own custom I/O object you typically just need to verify that it&amp;rsquo;s nonblocking
and then pass it to &lt;code&gt;PollEvented::new&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html&#34;&gt;&lt;code&gt;PollEvented&lt;/code&gt;&lt;/a&gt; type provides two ways to interact with it. First, if the
underlying type implements &lt;code&gt;Read&lt;/code&gt; and/or &lt;code&gt;Write&lt;/code&gt; then &lt;code&gt;PollEvented&amp;lt;E&amp;gt;&lt;/code&gt; will also
implement &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;AsyncRead&lt;/code&gt;, &lt;code&gt;Write&lt;/code&gt;, and &lt;code&gt;AsyncWrite&lt;/code&gt;. The underlying
implementation &lt;strong&gt;must&lt;/strong&gt; be nonblocking and &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html&#34;&gt;&lt;code&gt;PollEvented&lt;/code&gt;&lt;/a&gt; will layer task
management on top so all you need to do is call &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re working with objects that don&amp;rsquo;t implement &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Write&lt;/code&gt;, like UDP
sockets, then the raw methods to use are &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html#method.poll_read&#34;&gt;&lt;code&gt;poll_read&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html#method.need_read&#34;&gt;&lt;code&gt;need_read&lt;/code&gt;&lt;/a&gt;, (similarly for writes). To see an example of how to use these
let&amp;rsquo;s take a look at the implementation of &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/net/struct.UdpSocket.html#method.recv_from&#34;&gt;&lt;code&gt;UdpSocket::recv_from&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;pub fn recv_from(&amp;amp;self, buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;(usize, SocketAddr)&amp;gt; {
    if let Async::NotReady = self.io.poll_read() {
	return Err(mio::would_block())
    }
    match self.io.get_ref().recv_from(buf) {
	Ok(Some(n)) =&amp;gt; Ok(n),
	Ok(None) =&amp;gt; {
	    self.io.need_read();
	    Err(mio::would_block())
	}
	Err(e) =&amp;gt; Err(e),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we are required to call [&lt;code&gt;poll_read&lt;/code&gt;]. This will register our interest in
consuming the read readiness of the underlying object. This will also implicitly
register our task to get unparked if we&amp;rsquo;re not yet readable. After
[&lt;code&gt;poll_read&lt;/code&gt;] returns &lt;code&gt;Ready&lt;/code&gt; we can access the underlying object with
&lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html#method.get_ref&#34;&gt;&lt;code&gt;get_ref&lt;/code&gt;&lt;/a&gt; and call the actual nonblocking operation.&lt;/p&gt;

&lt;p&gt;In this case we&amp;rsquo;re actually calling &lt;a href=&#34;https://docs.rs/mio/0.6/mio/udp/struct.UdpSocket.html#method.recv_from&#34;&gt;&lt;code&gt;mio::UdpSocket::recv_from&lt;/code&gt;&lt;/a&gt; which returns
&lt;code&gt;Ok(None)&lt;/code&gt; on &amp;ldquo;would block&amp;rdquo;, and otherwise we just pass through the return
value.  Once we see &amp;ldquo;would block&amp;rdquo;, however, we inform our instance of
&lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html&#34;&gt;&lt;code&gt;PollEvented&lt;/code&gt;&lt;/a&gt; that we&amp;rsquo;re no longer readable through the &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html#method.need_read&#34;&gt;&lt;code&gt;need_read&lt;/code&gt;&lt;/a&gt; method.
This will, like &lt;code&gt;NotReady&lt;/code&gt; from [&lt;code&gt;poll_read&lt;/code&gt;], register the current task to
receive a notification when the I/O object is readable.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s it for implementing a custom I/O object with &lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt;! You&amp;rsquo;ll
need to be sure to implement the &lt;a href=&#34;https://docs.rs/mio/0.6/mio/trait.Evented.html&#34;&gt;&lt;code&gt;Evented&lt;/code&gt;&lt;/a&gt; trait from the &lt;a href=&#34;https://github.com/carllerche/mio&#34;&gt;&lt;code&gt;mio&lt;/code&gt;&lt;/a&gt; crate as
well because &lt;a href=&#34;https://github.com/carllerche/mio&#34;&gt;&lt;code&gt;mio&lt;/code&gt;&lt;/a&gt; is the backbone of &lt;a href=&#34;https://github.com/tokio-rs/tokio-core&#34;&gt;&lt;code&gt;tokio-core&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;wakeup-semantics&#34;&gt;&lt;a href=&#34;#wakeup-semantics&#34;&gt;Wakeup semantics&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;When working directly with &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html&#34;&gt;&lt;code&gt;PollEvented&lt;/code&gt;&lt;/a&gt; it&amp;rsquo;s important to understand how
tasks are actually woken up. Otherwise, a mistaken call to a method like &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html#method.need_read&#34;&gt;&lt;code&gt;need_read&lt;/code&gt;&lt;/a&gt;
could accidentally block your program forever!&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html#method.need_read&#34;&gt;&lt;code&gt;need_read&lt;/code&gt;&lt;/a&gt; method (and the write version) have a special requirement that
they will not operate correctly unless the I/O object was previously witnessed
to not be readable. If the I/O object is already readable and &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html#method.need_read&#34;&gt;&lt;code&gt;need_read&lt;/code&gt;&lt;/a&gt; is
called, then the current task may never receive a notification that the object
is readable.&lt;/p&gt;

&lt;p&gt;This currently corresponds to &amp;ldquo;edge semantics&amp;rdquo; with epoll and kqueue, meaning
that notifications are only received when the state changes for an I/O object.
The &lt;a href=&#34;https://docs.rs/tokio-core/0.1/tokio_core/reactor/struct.PollEvented.html&#34;&gt;&lt;code&gt;PollEvented&lt;/code&gt;&lt;/a&gt; may one day provide configuration to receive &amp;ldquo;level&amp;rdquo;
semantics where notifications are continually received while an object is
readable, but that is not currently implemented.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Multiplexed protocols</title>
      <link>https://tokio-cn.github.io/legacy/going-deeper-tokio/multiplex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/going-deeper-tokio/multiplex/</guid>
      <description>

&lt;p&gt;A &lt;em&gt;multiplexed&lt;/em&gt; socket connection is one that allows many concurrent requests to
be issued, with responses coming back in the order they are ready, rather than
in the order requested. Multiplexing allows a server to begin processing
requests as soon as they are received and to respond to the client as soon as
the request is processed. Generally, multiplexed protocols will make better
usage of available resources like TCP sockets.&lt;/p&gt;

&lt;p&gt;Since responses arrive out of order, a &lt;strong&gt;request ID&lt;/strong&gt; is used to match
responses with their associated requests. When the client issues a request, the
request will be paired with an identifier. The server processes the request, and
sends a response to the client paired with the same request identifier. This
allows the client to match the response with the request that it issued.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://tokio-cn.github.io/img/diagrams/multiplexing.png&#34; alt=&#34;Flow of multiplexed requests and responses&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Flow of multiplexed requests and responses
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;Tokio makes implementing multiplexed clients and servers easy. This
guide will show how.&lt;/p&gt;

&lt;h2 id=&#34;overview&#34;&gt;&lt;a href=&#34;#overview&#34;&gt;Overview&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Just as with the &lt;a href=&#34;../../getting-started/simple-server&#34;&gt;echo server&lt;/a&gt; guide,
implementing a client or server for a multiplexed protocol is done in three
parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A &lt;strong&gt;transport&lt;/strong&gt;, which manages serialization of Rust request and response
types to the underlying socket. In this guide, we will implement this using
the &lt;code&gt;framed&lt;/code&gt; helper, just as before.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;strong&gt;protocol specification&lt;/strong&gt;, which puts together a codec and some basic
information about the protocol.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;strong&gt;service&lt;/strong&gt;, which says how to produce a response given a request. A
service is basically an asynchronous function.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each part can vary independently, so once you&amp;rsquo;ve implemented a protocol
(like HTTP), you can pair it with a number of different services.&lt;/p&gt;

&lt;p&gt;This guide specifically covers implementing a &lt;strong&gt;simple&lt;/strong&gt; multiplexed protocol.
The &lt;a href=&#34;../streaming&#34;&gt;next section&lt;/a&gt; will show how to implement a streaming protocol.&lt;/p&gt;

&lt;p&gt;The full implementation can be found in the
&lt;a href=&#34;https://github.com/tokio-rs/tokio-line/blob/master/multiplexed/src/lib.rs&#34;&gt;tokio-line&lt;/a&gt;
repository. Let&amp;rsquo;s take it step by step.&lt;/p&gt;

&lt;h2 id=&#34;implement-transport&#34;&gt;&lt;a href=&#34;#implement-transport&#34;&gt;Step 1: Implement a transport&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;In Tokio, a &lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-tokio/architecture/#framing&#34;&gt;transport&lt;/a&gt; is any type
implementing &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;&lt;code&gt;+
&lt;/code&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html&#34;&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/a&gt; where the yielded
items are frames.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll implement the same line-based protocol as in the
&lt;a href=&#34;../../getting-started/simple-server&#34;&gt;echo server&lt;/a&gt; guide, but this time, we will
make it multiplexed. The protocol being implemented is a stream of frames, where
each frame is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4 byte header representing the numeric request ID in network byte order&lt;/li&gt;
&lt;li&gt;Frame payload, a UTF-8 encoded string of arbitrary length, terminated with a
&lt;code&gt;\n&lt;/code&gt; character.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that the lines themselves will not support containing &lt;em&gt;escaped&lt;/em&gt; new
line characters.&lt;/p&gt;

&lt;p&gt;For our transport to be compatible with tokio-proto&amp;rsquo;s multiplexer, the frame
must be structured as a pair of a request identifier and a payload:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;use tokio_proto::multiplex::RequestId;

type MyMultiplexedFrame&amp;lt;T&amp;gt; = (RequestId, T);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;T&lt;/code&gt; here represents the request or response type used for the &lt;code&gt;Service&lt;/code&gt;.
&lt;code&gt;tokio-proto&lt;/code&gt; will use the &lt;code&gt;RequestId&lt;/code&gt; in the frame to match outstanding
requests with responses.&lt;/p&gt;

&lt;p&gt;We will use &lt;code&gt;Encoder&lt;/code&gt;/&lt;code&gt;Decoder&lt;/code&gt; traits and the &lt;code&gt;AsyncRead::framed&lt;/code&gt; helper to
help us go from a &lt;code&gt;TcpStream&lt;/code&gt; to a &lt;code&gt;Stream + Sink&lt;/code&gt; for our frame type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_core;
# extern crate tokio_proto;
# extern crate bytes;
# extern crate tokio_io;
#
# use std::io;
# use std::str;
#
# use tokio_proto::multiplex::RequestId;
# use bytes::{Buf, BigEndian, BytesMut, BufMut, IntoBuf};
# use tokio_io::codec::{Encoder, Decoder};
#
struct LineCodec;

impl Decoder for LineCodec {
    type Item = (RequestId, String);
    type Error = io::Error;

    fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut)
             -&amp;gt; io::Result&amp;lt;Option&amp;lt;(RequestId, String)&amp;gt;&amp;gt;
    {
        // At least 5 bytes are required for a frame: 4 byte
        // head + one byte &#39;\n&#39;
        if buf.len() &amp;lt; 5 {
            // We don&#39;t yet have a full message
            return Ok(None);
        }

        // Check to see if the frame contains a new line, skipping
        // the first 4 bytes which is the request ID
        let newline = buf[4..].iter().position(|b| *b == b&#39;\n&#39;);
        if let Some(n) = newline {
            // remove the serialized frame from the buffer.
            let mut line = buf.split_to(n + 4);

            // Also remove the &#39;\n&#39;
            buf.split_to(1);

            // Deserialize the request ID
            let id = line.split_to(4).into_buf().get_u32::&amp;lt;BigEndian&amp;gt;();

            // Turn this data into a UTF string and return it in a Frame.
            return match str::from_utf8(&amp;amp;line[..]) {
                Ok(s) =&amp;gt; Ok(Some((id as RequestId, s.to_string()))),
                Err(_) =&amp;gt; Err(io::Error::new(io::ErrorKind::Other,
                                             &amp;quot;invalid string&amp;quot;)),
            }
        }

        // No `\n` found, so we don&#39;t have a complete message
        Ok(None)
    }
}

impl Encoder for LineCodec {
    type Item = (RequestId, String);
    type Error = io::Error;

    fn encode(&amp;amp;mut self,
              msg: (RequestId, String),
              buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt;
    {
        let (id, msg) = msg;

        buf.put_u32::&amp;lt;BigEndian&amp;gt;(id as u32);
        buf.put(msg.as_bytes());
        buf.put(&amp;quot;\n&amp;quot;);

        Ok(())
    }
}
#
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s almost exactly the same as the codec that we implemented in the &lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/simple-server/&#34;&gt;simple
server&lt;/a&gt; example. The main difference is
that the codec encodes and decodes frames that include the &lt;code&gt;RequestId&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;specify-protocol&#34;&gt;&lt;a href=&#34;#specify-protocol&#34;&gt;Step 2: Specify the protocol&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The next step is to define the protocol details.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;use tokio_proto::multiplex::ServerProto;

struct LineProto;

impl&amp;lt;T: AsyncRead + AsyncWrite + &#39;static&amp;gt; ServerProto&amp;lt;T&amp;gt; for LineProto {
    type Request = String;
    type Response = String;

    // `Framed&amp;lt;T, LineCodec&amp;gt;` is the return value
    // of `io.framed(LineCodec)`
    type Transport = Framed&amp;lt;T, LineCodec&amp;gt;;
    type BindTransport = Result&amp;lt;Self::Transport, io::Error&amp;gt;;

    fn bind_transport(&amp;amp;self, io: T) -&amp;gt; Self::BindTransport {
        Ok(io.framed(LineCodec))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is exactly the same as the &lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/simple-server/#specify-protocol&#34;&gt;simple
server&lt;/a&gt; example, except
that we are using &lt;code&gt;tokio_proto::multiplex::ServerProto&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;implement-service&#34;&gt;&lt;a href=&#34;#implement-service&#34;&gt;Step 3: Implement a service&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;This part is exactly the same as the &lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/simple-server/#implement-service&#34;&gt;simple
server&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;struct Echo;

impl Service for Echo {
    type Request = String;
    type Response = String;
    type Error = io::Error;
    type Future = Box&amp;lt;Future&amp;lt;Item = Self::Response, Error =  Self::Error&amp;gt;&amp;gt;;

    fn call(&amp;amp;self, req: Self::Request) -&amp;gt; Self::Future {
        Box::new(future::ok(req))
    }
}

fn main() {
    // Specify the localhost address
    let addr = &amp;quot;0.0.0.0:12345&amp;quot;.parse().unwrap();

    // The builder requires a protocol and an address
    let server = TcpServer::new(LineProto, addr);

    // We provide a way to *instantiate* the service for each new
    // connection; here, we just immediately return a new instance.
    server.serve(|| Ok(Echo));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interesting thing to note is that &lt;code&gt;RequestId&lt;/code&gt; does not show up as part of the
&lt;code&gt;Service&lt;/code&gt;&amp;rsquo;s request and response types. The &lt;code&gt;RequestId&lt;/code&gt; is only needed for
tokio-proto to manage the internal state of keeping requests and responses
matched when operating on the transport.&lt;/p&gt;

&lt;p&gt;Again, you can find the full working example
&lt;a href=&#34;https://github.com/tokio-rs/tokio-line/tree/master/multiplexed&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Returning futures</title>
      <link>https://tokio-cn.github.io/legacy/going-deeper-futures/returning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/going-deeper-futures/returning/</guid>
      <description>

&lt;p&gt;When working with futures, one of the first things you&amp;rsquo;re likely to need to do
is to return a &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html&#34;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;. As with &lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s, however, doing so can be a little tricky.
There are several options, listed from most to least ergonomic:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#trait-objects&#34;&gt;Trait objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#impl-trait&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#named-types&#34;&gt;Named types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#custom-types&#34;&gt;Custom types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;trait-objects&#34;&gt;&lt;a href=&#34;#trait-objects&#34;&gt;Trait objects&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;First, you always have the option of returning a boxed &lt;a href=&#34;https://doc.rust-lang.org/book/trait-objects.html&#34;&gt;trait object&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate futures;
# use std::io;
# use futures::Future;
# fn main() {}
fn foo() -&amp;gt; Box&amp;lt;Future&amp;lt;Item = u32, Error = io::Error&amp;gt;&amp;gt; {
    // ...
# loop {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The upside of this strategy is that it&amp;rsquo;s easy to write down (just a &lt;a href=&#34;https://doc.rust-lang.org/std/boxed/struct.Box.html&#34;&gt;&lt;code&gt;Box&lt;/code&gt;&lt;/a&gt;) and
easy to create. This is also maximally flexible in terms of future changes to
the method as &lt;em&gt;any&lt;/em&gt; type of future can be returned as an opaque, boxed &lt;code&gt;Future&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The downside of this approach is that it requires a runtime allocation when the
future is constructed, and dynamic dispatch when using that future. The &lt;code&gt;Box&lt;/code&gt;
needs to be allocated on the heap and the future itself is then placed
inside. Note, though that this is the &lt;em&gt;only&lt;/em&gt; allocation here, otherwise while
the future is being executed no allocations will be made.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s often possible to mitigate that cost by boxing only at the end of a long
chain of futures you want to return, which entails only a single allocation and
dynamic dispatch for the entire chain.&lt;/p&gt;

&lt;h3 id=&#34;impl-trait&#34;&gt;&lt;a href=&#34;#impl-trait&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;In an ideal world, however, we can have our cake and eat it too with a new
language feature called &lt;a href=&#34;https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;. This language feature will allow, for
example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;fn add_10&amp;lt;F&amp;gt;(f: F) -&amp;gt; impl Future&amp;lt;Item = i32, Error = F::Error&amp;gt;
    where F: Future&amp;lt;Item = i32&amp;gt;,
{
    f.map(|i| i + 10)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;re indicating that the return type is &amp;ldquo;something that implements
&lt;code&gt;Future&lt;/code&gt;&amp;rdquo; with the given associated types. Other than that we just use the
future combinators as we normally would.&lt;/p&gt;

&lt;p&gt;The upsides to this approach are that it is zero overhead with no &lt;code&gt;Box&lt;/code&gt;
necessary, it&amp;rsquo;s maximally flexible to future implementations as the actual
return type is hidden, and it&amp;rsquo;s ergonomic to write as it&amp;rsquo;s similar to the nice
&lt;code&gt;Box&lt;/code&gt; example above.&lt;/p&gt;

&lt;p&gt;The downside to this approach is only that it&amp;rsquo;s not on stable Rust yet. As of
the time of this writing &lt;a href=&#34;https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt; is available on nightly, but will likely
take some time to stabilize. You can track the progress of this feature at
&lt;a href=&#34;https://github.com/rust-lang/rust/issues/34511&#34;&gt;rust-lang/rust#34511&lt;/a&gt;. The good news, however, is that as soon as &lt;code&gt;impl
Trait&lt;/code&gt; hits stable Rust, all crates using futures can immediately benefit. It
should be a backwards-compatible extension to change return types from &lt;code&gt;Box&lt;/code&gt; to
&lt;a href=&#34;https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md&#34;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;named-types&#34;&gt;&lt;a href=&#34;#named-types&#34;&gt;Named types&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;If you wouldn&amp;rsquo;t like to return a &lt;code&gt;Box&lt;/code&gt; and want to stick with stable Rust, another
option is to write the return type directly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate futures;
# use futures::Future;
# use futures::future::Map;
# fn main() {}
fn add_10&amp;lt;F&amp;gt;(f: F) -&amp;gt; Map&amp;lt;F, fn(i32) -&amp;gt; i32&amp;gt;
    where F: Future&amp;lt;Item = i32&amp;gt;,
{
    fn do_map(i: i32) -&amp;gt; i32 { i + 10 }
    f.map(do_map)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we name the return type exactly as the compiler sees it. The &lt;code&gt;map&lt;/code&gt;
function returns the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/struct.Map.html&#34;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; struct which internally contains the future and the
function to perform the map.&lt;/p&gt;

&lt;p&gt;The upside to this approach is that it doesn&amp;rsquo;t have the runtime overhead of
&lt;code&gt;Box&lt;/code&gt; from before, and works on stable Rust.&lt;/p&gt;

&lt;p&gt;The downside, however, is that it&amp;rsquo;s often quite difficult to name the type.
Sometimes the types can get quite large or be unnameable altogether. Here we&amp;rsquo;re
using a function pointer (&lt;code&gt;fn(i32) -&amp;gt; i32&lt;/code&gt;), but we would ideally use a closure.
Unfortunately, the return type cannot name the closure, for now. It also leads to
very verbose signatures, and leaks implementation details to clients.&lt;/p&gt;

&lt;h3 id=&#34;custom-types&#34;&gt;&lt;a href=&#34;#custom-types&#34;&gt;Custom types&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Finally, you can wrap the concrete return type in a new type, and implement
future for it. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;struct MyFuture {
    inner: Sender&amp;lt;i32&amp;gt;,
}

fn foo() -&amp;gt; MyFuture {
    let (tx, rx) = oneshot::channel();
    // ...
    MyFuture { inner: tx }
}

impl Future for MyFuture {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example we&amp;rsquo;re returning a custom type, &lt;code&gt;MyFuture&lt;/code&gt;, and we implement the
&lt;code&gt;Future&lt;/code&gt; trait directly for it. This implementation leverages an underlying
&lt;code&gt;Oneshot&amp;lt;i32&amp;gt;&lt;/code&gt;, but any other kind of protocol can also be implemented here as
well.&lt;/p&gt;

&lt;p&gt;The upside to this approach is that it won&amp;rsquo;t require a &lt;code&gt;Box&lt;/code&gt; allocation and it&amp;rsquo;s
still maximally flexible. The implementation details of &lt;code&gt;MyFuture&lt;/code&gt; are hidden to
the outside world so it can change without breaking others.&lt;/p&gt;

&lt;p&gt;The downside to this approach, however, is that this is the least ergonomic way
to return futures.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Streaming protocols</title>
      <link>https://tokio-cn.github.io/legacy/going-deeper-tokio/streaming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/going-deeper-tokio/streaming/</guid>
      <description>

&lt;p&gt;All of the previous guides used protocols that where requests and responses were
comprised by a single message frame. In other words, the entire request and
response data had to be buffered before parsing the value, in turn forcing the
application to wait for all the data to be received before starting to
processing the request.&lt;/p&gt;

&lt;p&gt;Sometimes it is possible to begin processing the request before all data has
been received. For example, in HTTP, the application can start processing a
request once the head is received but before the body has been received. The
body of an HTTP request may be large, so it is useful for the application to be
able to stream in the body in chunks as it is received.&lt;/p&gt;

&lt;h2 id=&#34;overview&#34;&gt;&lt;a href=&#34;#overview&#34;&gt;Overview&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Just like in the &lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/simple-server/&#34;&gt;echo server&lt;/a&gt; guide,
implementing a client or server for a multiplexed protocol is done in three
parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A &lt;strong&gt;transport&lt;/strong&gt;, which manages serialization of Rust request and response
types to the underlying socket. In this guide, we will implement this using
the &lt;code&gt;framed&lt;/code&gt; helper.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;strong&gt;protocol specification&lt;/strong&gt;, which puts together a codec and some basic
information about the protocol.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;strong&gt;service&lt;/strong&gt;, which says how to produce a response given a request. A
service is basically an asynchronous function.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each part can vary independently, so once you&amp;rsquo;ve implemented a protocol
(like HTTP), you can pair it with a number of different services.&lt;/p&gt;

&lt;p&gt;This guide specifically covers implementing a &lt;strong&gt;pipelined&lt;/strong&gt; streaming protocol.
Implementing a multiplexed streaming protocol is similar and just requires using
the equivalent traits and types from the &lt;a href=&#34;https://tokio-rs.github.io/tokio-proto/tokio_proto/streaming/multiplex/index.html&#34;&gt;&lt;code&gt;multiplex&lt;/code&gt;&lt;/a&gt; module.&lt;/p&gt;

&lt;p&gt;A full implementation can be found in the
&lt;a href=&#34;https://github.com/tokio-rs/tokio-line/blob/master/streaming/src/lib.rs&#34;&gt;tokio-line&lt;/a&gt;
repository. Let&amp;rsquo;s see how it&amp;rsquo;s done.&lt;/p&gt;

&lt;h2 id=&#34;implement-transport&#34;&gt;&lt;a href=&#34;#implement-transport&#34;&gt;Step 1: Implement a transport&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;In Tokio, a &lt;a href=&#34;https://tokio-cn.github.io/legacy/going-deeper-tokio/architecture/#framing&#34;&gt;transport&lt;/a&gt; is any type
implementing &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;&lt;code&gt;+
&lt;/code&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html&#34;&gt;&lt;code&gt;Sink&lt;/code&gt;&lt;/a&gt; where the yielded
items are frames.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll implement the same line-based protocol as in the &lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/simple-server/&#34;&gt;echo
server&lt;/a&gt; guide, but this time, we will make
it streaming. The protocol being implemented is a stream of frames, where each
frame is a UTF-8 encoded string terminated by a &lt;code&gt;\n&lt;/code&gt; character. If an empty line
is received, then the line will be streamed in chunks. All following frames are
chunks of the line until another empty line is reached, which represents the
termination of the streaming line.&lt;/p&gt;

&lt;p&gt;For our transport to be compatible with tokio-proto&amp;rsquo;s streaming support, the
transport&amp;rsquo;s frame type must be an instance of &lt;a href=&#34;https://tokio-rs.github.io/tokio-proto/tokio_proto/streaming/pipeline/enum.Frame.html&#34;&gt;&lt;code&gt;pipeline::Frame&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;pub enum Frame&amp;lt;T, B, E&amp;gt; {
    Message {
        message: T,
        body: bool,
    },
    Body {
        chunk: Option&amp;lt;B&amp;gt;,
    },
    Error {
        error: E,
    },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;T&lt;/code&gt; represents the request or response head type and &lt;code&gt;B&lt;/code&gt; represents the
type of each stream chunk. &lt;code&gt;E&lt;/code&gt; is not used as part of this guide, but it
represents the type of an error frame. We will just set it to &lt;code&gt;io::Error&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By having our &lt;code&gt;Decoder&lt;/code&gt; yield frames of this type, &lt;code&gt;tokio-proto&lt;/code&gt; is able to
dispatch the streaming body frames appropriately.&lt;/p&gt;

&lt;p&gt;Again, we will use &lt;code&gt;Encoder&lt;/code&gt;, &lt;code&gt;Decoder&lt;/code&gt; and the &lt;code&gt;AsyncRead::framed&lt;/code&gt; helper to
help us go from a &lt;code&gt;TcpStream&lt;/code&gt; to a &lt;code&gt;Stream + Sink&lt;/code&gt; for our frame type. Unlike
previous examples, our codec will retain some state for parsing (which is
typical for streaming protocols):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate bytes;
# extern crate tokio_io;
# extern crate tokio_proto;
#
# use std::io;
# use std::str;
#
# use bytes::{BytesMut, IntoBuf, Buf, BufMut};
# use tokio_io::codec::{Encoder, Decoder};
# use tokio_proto::streaming::pipeline::Frame;
#
pub struct LineCodec {
    decoding_head: bool,
}

impl Decoder for LineCodec {
    type Item = Frame&amp;lt;String, String, io::Error&amp;gt;;
    type Error = io::Error;

    fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut)
        -&amp;gt; Result&amp;lt;Option&amp;lt;Self::Item&amp;gt;, io::Error&amp;gt;
    {
        // Find the position of the next newline character and split off the
        // line if we find it.
        let line = match buf.iter().position(|b| *b == b&#39;\n&#39;) {
            Some(n) =&amp;gt; buf.split_to(n),
            None =&amp;gt; return Ok(None),
        };

        // Also remove the &#39;\n&#39;
        buf.split_to(1);

        // Turn this data into a string and return it in a Frame
        let s = try!(str::from_utf8(&amp;amp;line).map_err(|e| {
            io::Error::new(io::ErrorKind::Other, e)
        }));

        // Got an empty line, which means that the state
        // should be toggled.
        if s == &amp;quot;&amp;quot; {
            let decoding_head = self.decoding_head;
            // Toggle the state
            self.decoding_head = !decoding_head;

            if decoding_head {
                Ok(Some(Frame::Message {
                    // The message head is an empty line
                    message: s.to_string(),
                    // We will be streaming a body next
                    body: true,
                }))
            } else {
                // The streaming body termination frame,
                // is represented as `None`.
                Ok(Some(Frame::Body {
                    chunk: None
                }))
            }
        } else {
            if self.decoding_head {
                // This is a &amp;quot;oneshot&amp;quot; message with no
                // streaming body
                Ok(Some(Frame::Message {
                    message: s.to_string(),
                    body: false,
                }))
            } else {
                // Streaming body line chunk
                Ok(Some(Frame::Body {
                    chunk: Some(s.to_string()),
                }))
            }
        }
    }
}

impl Encoder for LineCodec {
    type Item = Frame&amp;lt;String, String, io::Error&amp;gt;;
    type Error = io::Error;

    fn encode(&amp;amp;mut self, msg: Self::Item, buf: &amp;amp;mut BytesMut)
        -&amp;gt; io::Result&amp;lt;()&amp;gt;
    {
        match msg {
            Frame::Message { message, body } =&amp;gt; {
                // Our protocol dictates that a message head that
                // includes a streaming body is an empty string.
                assert!(message.is_empty() == body);

                buf.extend(message.as_bytes());
            }
            Frame::Body { chunk } =&amp;gt; {
                if let Some(chunk) = chunk {
                    buf.extend(chunk.as_bytes());
                }
            }
            Frame::Error { error } =&amp;gt; {
                // Our protocol does not support error frames, so
                // this results in a connection level error, which
                // will terminate the socket.
                return Err(error)
            }
        }

        // Push the new line
        buf.extend(b&amp;quot;\n&amp;quot;);

        Ok(())
    }
}
#
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The implementation is similar in spirit to the codec we implemented in the
&lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/simple-server/&#34;&gt;echo server&lt;/a&gt; example. The main difference
is that we are returning &lt;code&gt;pipeline::Frame&lt;/code&gt; values and we are differentiating
between the message head and a body chunk.&lt;/p&gt;

&lt;h2 id=&#34;specify-protocol&#34;&gt;&lt;a href=&#34;#specify-protocol&#34;&gt;Step 2: Specify the protocol&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The next step is to define the protocol details:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;# extern crate tokio_proto;
# extern crate tokio_io;
# extern crate bytes;
#
# use std::io;
#
# use bytes::BytesMut;
# use tokio_io::{AsyncRead, AsyncWrite};
# use tokio_io::codec::{Encoder, Decoder, Framed};
# use tokio_proto::streaming::pipeline::{Frame, ServerProto};
#
# pub struct LineCodec {
#     decoding_head: bool,
# }
#
# impl Decoder for LineCodec {
#     type Item = Frame&amp;lt;String, String, io::Error&amp;gt;;
#     type Error = io::Error;
#
#     fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut) -&amp;gt; Result&amp;lt;Option&amp;lt;Self::Item&amp;gt;, io::Error&amp;gt; {
#         unimplemented!();
#     }
# }
#
# impl Encoder for LineCodec {
#     type Item = Frame&amp;lt;String, String, io::Error&amp;gt;;
#     type Error = io::Error;
#
#     fn encode(&amp;amp;mut self, msg: Self::Item, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
#         unimplemented!();
#     }
# }
struct LineProto;

impl&amp;lt;T: AsyncRead + AsyncWrite + &#39;static&amp;gt; ServerProto&amp;lt;T&amp;gt; for LineProto {
    type Request = String;
    type RequestBody = String;
    type Response = String;
    type ResponseBody = String;
    type Error = io::Error;

    // `Framed&amp;lt;T, LineCodec&amp;gt;` is the return value
    // of `io.framed(LineCodec)`
    type Transport = Framed&amp;lt;T, LineCodec&amp;gt;;
    type BindTransport = Result&amp;lt;Self::Transport, io::Error&amp;gt;;

    fn bind_transport(&amp;amp;self, io: T) -&amp;gt; Self::BindTransport {
        // Initialize the codec to be parsing message heads
        let codec = LineCodec {
            decoding_head: true,
        };

        Ok(io.framed(codec))
    }
}
#
# fn main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two additional associated types compared to the non-streaming version
of &lt;code&gt;ServerProto&lt;/code&gt;: &lt;code&gt;RequestBody&lt;/code&gt; and &lt;code&gt;ResponseBody&lt;/code&gt;. This is the type of the
streaming body chunks, and they can differ from the &lt;code&gt;Request&lt;/code&gt; and &lt;code&gt;Response&lt;/code&gt;
types. So, for HTTP, the &lt;code&gt;Request&lt;/code&gt; type may be &lt;code&gt;HttpRequestHead&lt;/code&gt; and the
&lt;code&gt;RequestBody&lt;/code&gt; type could be set to &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; to represent streaming in the
request body as a sequence of bytes. Here, we use &lt;code&gt;String&lt;/code&gt; for both directions.&lt;/p&gt;

&lt;h2 id=&#34;implement-service&#34;&gt;&lt;a href=&#34;#implement-service&#34;&gt;Step 3: Implement a service&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Request&lt;/code&gt; and &lt;code&gt;Response&lt;/code&gt; types for a streaming protocol &lt;code&gt;Service&lt;/code&gt; is
required to be &lt;a href=&#34;https://tokio-rs.github.io/tokio-proto/tokio_proto/streaming/enum.Message.html&#34;&gt;&lt;code&gt;tokio_proto::streaming::Message&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;pub enum Message&amp;lt;T, B&amp;gt; {
    WithoutBody(T),
    WithBody(T, B),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here &lt;code&gt;T&lt;/code&gt; will be the message head and &lt;code&gt;B&lt;/code&gt; will be a &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; of the body chunk type. &lt;code&gt;B&lt;/code&gt; is usually
set to &lt;a href=&#34;https://tokio-rs.github.io/tokio-proto/tokio_proto/streaming/struct.Body.html&#34;&gt;&lt;code&gt;Body&lt;/code&gt;&lt;/a&gt;, but this is not a requirement.&lt;/p&gt;

&lt;p&gt;This step is similar to the
&lt;a href=&#34;https://tokio-cn.github.io/legacy/getting-started/simple-server/#implement-service&#34;&gt;echo server&lt;/a&gt;, except for
the change in types for the &lt;code&gt;Service&lt;/code&gt;, which allows working with body streams:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,no_run&#34;&gt;# extern crate futures;
# extern crate tokio_io;
# extern crate tokio_proto;
# extern crate tokio_service;
# extern crate bytes;
#
# use futures::{future, Future, Stream};
# use tokio_service::Service;
#
# use std::io;
#
# use tokio_io::{AsyncRead, AsyncWrite};
# use tokio_io::codec::{Framed, Encoder, Decoder};
# use tokio_proto::TcpServer;
# use tokio_proto::streaming::{Message, Body};
# use tokio_proto::streaming::pipeline::{Frame, ServerProto};
# use bytes::{BytesMut};
#
# pub struct LineCodec {
#     decoding_head: bool,
# }
#
# impl Decoder for LineCodec {
#     type Item = Frame&amp;lt;String, String, io::Error&amp;gt;;
#     type Error = io::Error;
#
#     fn decode(&amp;amp;mut self, buf: &amp;amp;mut BytesMut) -&amp;gt; Result&amp;lt;Option&amp;lt;Self::Item&amp;gt;, io::Error&amp;gt; {
#         unimplemented!();
#     }
# }
# impl Encoder for LineCodec {
#     type Item = Frame&amp;lt;String, String, io::Error&amp;gt;;
#     type Error = io::Error;
#
#     fn encode(&amp;amp;mut self, msg: Self::Item, buf: &amp;amp;mut BytesMut) -&amp;gt; io::Result&amp;lt;()&amp;gt; {
#         unimplemented!();
#     }
# }
# struct LineProto;
#
# impl&amp;lt;T: AsyncRead + AsyncWrite + &#39;static&amp;gt; ServerProto&amp;lt;T&amp;gt; for LineProto {
#     type Request = String;
#     type RequestBody = String;
#     type Response = String;
#     type ResponseBody = String;
#     type Error = io::Error;
#
#     type Transport = Framed&amp;lt;T, LineCodec&amp;gt;;
#     type BindTransport = Result&amp;lt;Self::Transport, io::Error&amp;gt;;
#
#     fn bind_transport(&amp;amp;self, io: T) -&amp;gt; Self::BindTransport {
#         unimplemented!();
#     }
# }

struct PrintStdout;

impl Service for PrintStdout {
    type Request = Message&amp;lt;String, Body&amp;lt;String, io::Error&amp;gt;&amp;gt;;
    type Response = Message&amp;lt;String, Body&amp;lt;String, io::Error&amp;gt;&amp;gt;;
    type Error = io::Error;
    type Future = Box&amp;lt;Future&amp;lt;Item = Self::Response,
                            Error = Self::Error&amp;gt;&amp;gt;;

    fn call(&amp;amp;self, req: Self::Request) -&amp;gt; Self::Future {
        let resp = Message::WithoutBody(&amp;quot;Ok&amp;quot;.to_string());

        match req {
            Message::WithoutBody(line) =&amp;gt; {
                println!(&amp;quot;{}&amp;quot;, line);
                Box::new(future::done(Ok(resp)))
            }
            Message::WithBody(_, body) =&amp;gt; {
                let resp = body
                    .for_each(|line| {
                        println!(&amp;quot; + {}&amp;quot;, line);
                        Ok(())
                    })
                    .map(move |_| resp);

                Box::new(resp) as Self::Future
            }
        }
    }
}

fn main() {
    // Specify the localhost address
    let addr = &amp;quot;0.0.0.0:12345&amp;quot;.parse().unwrap();

    // The builder requires a protocol and an address
    let server = TcpServer::new(LineProto, addr);

    // We provide a way to *instantiate* the service for each new
    // connection; here, we just immediately return a new instance.
    server.serve(|| Ok(PrintStdout));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the service is able to stream in the response body chunks.&lt;/p&gt;

&lt;p&gt;In this example, we exposed the &lt;code&gt;Message&lt;/code&gt; and &lt;code&gt;Body&lt;/code&gt; types provided by
&lt;code&gt;tokio-proto&lt;/code&gt;. In practice, you will probably want to keep those types
encapsulated in your library and provide your own request, response, and body
stream types. You can see how this is done in the
&lt;a href=&#34;https://github.com/tokio-rs/tokio-line/blob/master/streaming/src/lib.rs&#34;&gt;full example&lt;/a&gt;,
specifically the &lt;code&gt;Line&lt;/code&gt;, &lt;code&gt;LineStream&lt;/code&gt;, &lt;code&gt;ServerTypeMap&lt;/code&gt;, and &lt;code&gt;ClientTypeMap&lt;/code&gt;
types.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Streams and sinks</title>
      <link>https://tokio-cn.github.io/legacy/getting-started/streams-and-sinks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio-cn.github.io/legacy/getting-started/streams-and-sinks/</guid>
      <description>

&lt;p&gt;We&amp;rsquo;ve now seen a few examples of futures, which represent a &lt;em&gt;one-time&lt;/em&gt;
asynchronous event. But there are a lot of cases where you want to deal with a
&lt;em&gt;series&lt;/em&gt; of events:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;incoming connections over time,&lt;/li&gt;
&lt;li&gt;incoming or outgoing network packets,&lt;/li&gt;
&lt;li&gt;incoming or outgoing chunks of a streaming protocol,&lt;/li&gt;
&lt;li&gt;repeated timeouts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and so on.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;futures&lt;/code&gt; library provides two abstractions that are similar to futures,
but work with series of events over time: streams and sinks. Streams are for
incoming events (which are caused by something external happening, like a
timeout firing) while sinks are for outgoing events (like sending a message
chunk).&lt;/p&gt;

&lt;h2 id=&#34;streams&#34;&gt;&lt;a href=&#34;#streams&#34;&gt;Streams&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s see how &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html&#34;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; relate to their synchronous equivalents
in the standard library:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;# items&lt;/th&gt;
&lt;th&gt;Sync&lt;/th&gt;
&lt;th&gt;Async&lt;/th&gt;
&lt;th&gt;Common operations&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/result/enum.Result.html&#34;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html&#34;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.map&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.fold&#34;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.collect&#34;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The definition of the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; trait also resembles that of &lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;trait Stream {
    // The type of item yielded each time the stream&#39;s event occurs
    type Item;

    // The error type; errors terminate the stream.
    type Error;

    // Try to produce a value.
    fn poll(&amp;amp;mut self) -&amp;gt; Poll&amp;lt;Option&amp;lt;Self::Item&amp;gt;, Self::Error&amp;gt;;

    // ... and many default methods; we&#39;ll see some of them below.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; trait is very similar to the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/future/trait.Future.html&#34;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; trait, except that a
stream&amp;rsquo;s &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#tymethod.poll&#34;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; method returns &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt; instead of
&lt;code&gt;Self::Item&lt;/code&gt;. The semantics are much like with &lt;a href=&#34;https://doc.rust-lang.org/std/iter/trait.Iterator.html&#34;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: yielding &lt;code&gt;None&lt;/code&gt;
means that the stream has terminated. Like futures, streams can produce
errors, which &lt;em&gt;also&lt;/em&gt; terminate the stream.&lt;/p&gt;

&lt;p&gt;The stream API is easiest to understand by example, so let&amp;rsquo;s write a little
server that immediately sends &amp;ldquo;Hello, world!&amp;rdquo; to each client that connects, and
then hangs up. (We&amp;rsquo;ll use &lt;code&gt;tokio-core&lt;/code&gt; in this example, which is covered in
greater depth in the next section.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,no_run&#34;&gt;extern crate futures;
extern crate tokio_core;
extern crate tokio_io;

use futures::stream::Stream;
use tokio_core::reactor::Core;
use tokio_core::net::TcpListener;

fn main() {
    let mut core = Core::new().unwrap();
    let address = &amp;quot;0.0.0.0:12345&amp;quot;.parse().unwrap();
    let listener = TcpListener::bind(&amp;amp;address, &amp;amp;core.handle()).unwrap();

    let connections = listener.incoming();
    let welcomes = connections.and_then(|(socket, _peer_addr)| {
        tokio_io::io::write_all(socket, b&amp;quot;Hello, world!\n&amp;quot;)
    });
    let server = welcomes.for_each(|(_socket, _welcome)| {
        Ok(())
    });

    core.run(server).unwrap();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was easy! Let&amp;rsquo;s pick apart a few key lines. First, there&amp;rsquo;s the &lt;em&gt;reactor setup&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let mut core = Core::new().unwrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll cover reactors (aka &lt;em&gt;event loops&lt;/em&gt;) in detail in the next section. For now,
it&amp;rsquo;s enough to know that if you&amp;rsquo;re doing asynchronous I/O, it needs to be
managed by a reactor. The &lt;code&gt;tokio-proto&lt;/code&gt; crate takes care of this for you, but
here we&amp;rsquo;re working at a lower level.&lt;/p&gt;

&lt;p&gt;We then set up an async TCP listener, associated with that reactor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let listener = TcpListener::bind(&amp;amp;address, &amp;amp;core.handle()).unwrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our first encounter with streams is the &lt;code&gt;incoming&lt;/code&gt; stream:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let connections = listener.incoming();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an unending stream of sockets, one for each
incoming connection. It&amp;rsquo;s an async version of
&lt;a href=&#34;https://static.rust-lang.org/doc/master/std/net/struct.TcpListener.html#method.incoming&#34;&gt;the same method&lt;/a&gt;
in the standard library. And just as with iterators, we can use the methods on
the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html&#34;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; trait to manipulate the stream:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let welcomes = connections.and_then(|(socket, _peer_addr)| {
    tokio_io::io::write_all(socket, b&amp;quot;Hello, world!\n&amp;quot;)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we use &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt; to perform an action over each item of
the stream, a bit like &lt;code&gt;and_then&lt;/code&gt; on &lt;code&gt;Result&lt;/code&gt;, except that the closure we give
&lt;code&gt;and_then&lt;/code&gt; produces a future. We get back a &lt;em&gt;new&lt;/em&gt; stream, &lt;code&gt;welcomes&lt;/code&gt;. Here&amp;rsquo;s how
&lt;code&gt;welcome&lt;/code&gt; produces its items:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First, get an item from &lt;code&gt;connections&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Then, map that item through the closure, getting back a future.&lt;/li&gt;
&lt;li&gt;When that future completes, return the item it produced as the next item of
the &lt;code&gt;welcomes&lt;/code&gt; stream.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The future we use is &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/io/fn.write_all.html&#34;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;tokio-io&lt;/code&gt; crate. It
asynchronously writes the entire buffer to the socket provided, then returns
the socket and ownership of that buffer. So &lt;code&gt;welcomes&lt;/code&gt; is again a stream that
includes one socket for each connection, with &lt;code&gt;Hello, world!&lt;/code&gt; written to them.
We&amp;rsquo;re done with the connection at that point.&lt;/p&gt;

&lt;p&gt;How do we actually consume this stream? As with iterators, loops are a common
way to consume streams&amp;mdash;but we use the futures-based &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.for_each&#34;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let server = welcomes.for_each(|(_socket, _welcome)| {
    Ok(())
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we take the results of the previous future, &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/io/fn.write_all.html&#34;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, and discard
them, closing the socket. What we get back is a &lt;em&gt;single future&lt;/em&gt;, &lt;code&gt;server&lt;/code&gt;, which
completes with &lt;code&gt;()&lt;/code&gt; only when the entire stream has been exhausted (and hence,
we&amp;rsquo;ve replied to all connections). It&amp;rsquo;s a pretty common pattern, when working
with streams, to ultimately &amp;ldquo;bottom things out&amp;rdquo; into a single future that
represents fully processing the stream.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s one final step: we need to consume the &lt;code&gt;server&lt;/code&gt; future, which is
otherwise inert, to actually trigger all this processing. We also need to start
up the reactor. We do both in a single step, by using the server as the &lt;em&gt;primary
future&lt;/em&gt; of the reactor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;core.run(server).unwrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reactor&amp;rsquo;s event loop will keep running on the current thread until the
server future completes successfully or with an error.&lt;/p&gt;

&lt;h5 id=&#34;concurrency&#34;&gt;&lt;a href=&#34;#concurrency&#34;&gt;Concurrency&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;There&amp;rsquo;s an important point to drive home about the previous example: it has &lt;em&gt;no
concurrency&lt;/em&gt;!  Streams represent in-order processing of data, and in this case
the order of the original stream is the order in which sockets are received,
which the &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.and_then&#34;&gt;&lt;code&gt;and_then&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://docs.rs/futures/0.1/futures/stream/trait.Stream.html#method.for_each&#34;&gt;&lt;code&gt;for_each&lt;/code&gt;&lt;/a&gt; combinators
preserve. Chaining these combinators therefore has the effect of taking each
socket from the stream and processing all chained operations on it before taking
the next socket.&lt;/p&gt;

&lt;p&gt;If, instead, we want to handle all clients concurrently, we can use the
reactor&amp;rsquo;s ability to &amp;ldquo;spawn&amp;rdquo; additional work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;let handle = core.handle();
let server = connections.for_each(|(socket, _peer_addr)| {
    let serve_one = tokio_io::io::write_all(socket, b&amp;quot;Hello, world!\n&amp;quot;)
            .then(|_| Ok(()));
    handle.spawn(serve_one);
    Ok(())
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Handle.html#method.spawn&#34;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; requires a future with &lt;code&gt;()&lt;/code&gt; item and error types, since the
result of the future is not accessible. We use &lt;code&gt;then&lt;/code&gt; to explicitly throw away
the socket returned from &lt;a href=&#34;https://docs.rs/tokio-io/0.1/tokio_io/io/fn.write_all.html&#34;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unlike with &lt;code&gt;CpuPool&lt;/code&gt;, the reactor is always an event loop that runs on a
&lt;em&gt;single&lt;/em&gt; thread (the one that calls &lt;code&gt;run&lt;/code&gt;). When we use &lt;a href=&#34;https://tokio-rs.github.io/tokio-core/tokio_core/reactor/struct.Handle.html#method.spawn&#34;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; to add work to
the reactor, we are effectively creating a &lt;em&gt;lightweight thread&lt;/em&gt;: we move the
future itself onto the reactor, and as relevant events arrive, the reactor will
attempt to run the future to completion. It&amp;rsquo;s important to be clear on the
mechanics here, so let&amp;rsquo;s work through an example.&lt;/p&gt;

&lt;p&gt;After calling &lt;code&gt;core.run&lt;/code&gt;, the event loop blocks until a connection
arrives. Suppose two connections arrive at the same time.  At that point, the
event loop will emit two sockets on the &lt;code&gt;connections&lt;/code&gt; stream, which will result
in two spawned &lt;code&gt;Hello, world!&lt;/code&gt; futures. The event loop will then attempt to
complete those futures, one at a time.  Each future will attempt to write to
its socket. If its socket is not ready to receive data, the future will go into
a &lt;em&gt;waiting state&lt;/em&gt; until the status of the socket changes; the event loop &lt;em&gt;does
not&lt;/em&gt; block. Once the socket &lt;em&gt;is&lt;/em&gt; ready, the event loop will again start trying
to make progress on the future.&lt;/p&gt;

&lt;p&gt;So we end up multiplexing all connection handling onto a single event loop
thread. That thread will make progress on all outstanding futures with I/O ready
to be performed, and will not be blocked by any future that has stalled waiting
for a socket. For a server as simple as this one, handling concurrency by
multiplexing onto a single thread is a big performance win compared to
coordinating multiple threads. In other cases, we might use a &lt;code&gt;CpuPool&lt;/code&gt; for
CPU-heavy work, and use the event loop primarily for I/O-heavy work, to try to
maximize locality and parallelism.&lt;/p&gt;

&lt;p&gt;All of the multiplexing and dispatch is handled behind the scenes by the reactor
and futures; we just write code that looks pretty close to synchronous code that
spawns a thread per connection.&lt;/p&gt;

&lt;h2 id=&#34;sinks&#34;&gt;&lt;a href=&#34;#sinks&#34;&gt;Sinks&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Sinks are essentially the opposite of streams: they are places that you can
asynchronously send many values over time. As usual, sinks are types that
implement the &lt;code&gt;Sink&lt;/code&gt; trait:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust,ignore&#34;&gt;trait Sink {
    // The type of value that the sink accepts.
    type SinkItem;

    // The type of value produced by the sink when an error occurs.
    type SinkError;

    // The analog to `poll`, used for sending and then flushing items.
    fn start_send(&amp;amp;mut self, item: Self::SinkItem)
                  -&amp;gt; StartSend&amp;lt;Self::SinkItem, Self::SinkError&amp;gt;;

    fn poll_complete(&amp;amp;mut self) -&amp;gt; Poll&amp;lt;(), Self::SinkError&amp;gt;;

    fn close(&amp;amp;mut self) -&amp;gt; Poll&amp;lt;(), Self::SinkError&amp;gt;;

    // ... and lots of default methods, as usual
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll see some example uses of sinks in the next section, so for now we&amp;rsquo;ll just
mention two of the most important methods it offers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html#method.send_all&#34;&gt;&lt;code&gt;send_all&lt;/code&gt;&lt;/a&gt; method takes a stream with &lt;code&gt;Item&lt;/code&gt; the same as &lt;code&gt;SinkItem&lt;/code&gt;, and
gives you back a future that produces &lt;code&gt;()&lt;/code&gt;. As the name suggests, this future,
when executed, will asynchronously send all items from the stream into the
sink, completing when the stream has been exhausted and all items have been
&lt;em&gt;flushed&lt;/em&gt; through the sink.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;a href=&#34;https://docs.rs/futures/0.1/futures/sink/trait.Sink.html#method.buffer&#34;&gt;&lt;code&gt;buffer&lt;/code&gt;&lt;/a&gt; method wraps a sink with a fixed-size buffer, allowing it to
accept additional items even when the underlying sink is not ready for
items. That&amp;rsquo;s useful for buffering up responses on a socket, for example.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of the time, the interesting work happens on the stream and future sides,
with sinks acting as a final endpoint for pushing data through.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>